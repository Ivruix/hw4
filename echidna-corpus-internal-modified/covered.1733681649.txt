/home/ivruix/Desktop/hw4/lib/properties/contracts/ERC721/internal/properties/ERC721BasicProperties.sol
   1 |     | pragma solidity ^0.8.13;
   2 |     | 
   3 |     | import "../util/ERC721TestBase.sol";
   4 |     | import "@openzeppelin/contracts/utils/Address.sol";
   5 |     | 
   6 |     | abstract contract CryticERC721BasicProperties is CryticERC721TestBase {
   7 |     |     using Address for address;
   8 |     | 
   9 |     |     ////////////////////////////////////////
  10 |     |     // Properties
  11 |     | 
  12 |     |     // Querying the balance of address(0) should throw
  13 | *   |     function test_ERC20_balanceOfZeroAddressMustRevert() public virtual {
  14 | *   |         balanceOf(address(0));
  15 | *   |         assertWithMsg(false, "address(0) balance query should have reverted");
  16 |     |     }
  17 |     | 
  18 |     |     // Querying the owner of an invalid token should throw
  19 | *   |     function test_ERC721_ownerOfInvalidTokenMustRevert(uint256 tokenId) public virtual {
  20 | *r  |         require(!_exists(tokenId));
  21 | *   |         ownerOf(tokenId);
  22 | *   |         assertWithMsg(false, "Invalid token owner query should have reverted");
  23 |     |     }
  24 |     | 
  25 |     |     // Approving an invalid token should throw
  26 | *   |     function test_ERC721_approvingInvalidTokenMustRevert(uint256 tokenId) public virtual {
  27 | *r  |         require(!_exists(tokenId));
  28 | *   |         approve(address(0), tokenId);
  29 |     |         assertWithMsg(false, "Approving an invalid token should have reverted");
  30 |     |     }
  31 |     | 
  32 |     |     // transferFrom a token that the caller is not approved for should revert
  33 | *   |     function test_ERC721_transferFromNotApproved(address target) public virtual {
  34 | *   |         uint256 selfBalance = balanceOf(target);
  35 | *r  |         require(selfBalance > 0);        
  36 | *   |         require(target != address(this));
  37 | *r  |         require(target != msg.sender);
  38 | *   |         uint tokenId = tokenOfOwnerByIndex(target, 0);
  39 | *   |         _approve(address(0), tokenId);
  40 | *   |         _setApprovalForAll(target, msg.sender, false);
  41 | *   |         require(ownerOf(tokenId) == target);
  42 |     | 
  43 | *   |         transferFrom(target, msg.sender, tokenId);
  44 |     |         assertWithMsg(false, "using transferFrom without being approved should have reverted");
  45 |     |     }
  46 |     | 
  47 |     |     // transferFrom should reset approval for that token
  48 | *   |     function test_ERC721_transferFromResetApproval(address target) public virtual {
  49 | *   |         uint256 selfBalance = balanceOf(msg.sender);
  50 | *r  |         require(selfBalance > 0);  
  51 | *r  |         require(target != address(this));
  52 | *r  |         require(target != msg.sender);
  53 | *r  |         require(target != address(0));
  54 | *   |         uint tokenId = tokenOfOwnerByIndex(msg.sender, 0);
  55 |     | 
  56 | *   |         hevm.prank(msg.sender);
  57 | *   |         try IERC721(address(this)).transferFrom(msg.sender, target, tokenId) {
  58 | *   |             address approved = getApproved(tokenId);
  59 | *   |             assertWithMsg(approved == address(0), "Approval was not reset");
  60 |     |         } catch {
  61 |     |             assertWithMsg(false, "transferFrom unexpectedly reverted");
  62 |     |         }
  63 |     |     }
  64 |     | 
  65 |     |     // transferFrom correctly updates owner
  66 | *   |     function test_ERC721_transferFromUpdatesOwner(address target) public virtual {
  67 | *   |         uint256 selfBalance = balanceOf(msg.sender);
  68 | *r  |         require(selfBalance > 0);  
  69 | *r  |         require(target != address(this));
  70 | *r  |         require(target != msg.sender);
  71 | *r  |         require(target != address(0));
  72 | *   |         uint tokenId = tokenOfOwnerByIndex(msg.sender, 0);
  73 |     | 
  74 | *   |         hevm.prank(msg.sender);
  75 | *   |         try IERC721(address(this)).transferFrom(msg.sender, target, tokenId) {
  76 | *   |             assertWithMsg(ownerOf(tokenId) == target, "Token owner not updated");
  77 |     |         } catch {
  78 |     |             assertWithMsg(false, "transferFrom unexpectedly reverted");
  79 |     |         }
  80 |     |     }
  81 |     | 
  82 | *   |     function test_ERC721_transferFromZeroAddress(address target, uint256 tokenId) public virtual {
  83 | *r  |         require(target != address(this));
  84 | *r  |         require(target != msg.sender);
  85 | *   |         transferFrom(address(0), target, tokenId);
  86 |     | 
  87 |     |         assertWithMsg(false, "Transfer from zero address did not revert");
  88 |     |     }
  89 |     | 
  90 |     |     // Transfers to the zero address should revert
  91 | *   |     function test_ERC721_transferToZeroAddress() public virtual {
  92 | *   |         uint256 selfBalance = balanceOf(msg.sender);
  93 | *r  |         require(selfBalance > 0); 
  94 | *   |         uint tokenId = tokenOfOwnerByIndex(msg.sender, 0);
  95 |     | 
  96 | *   |         transferFrom(msg.sender, address(0), tokenId);
  97 |     | 
  98 |     |         assertWithMsg(false, "Transfer to zero address should have reverted");
  99 |     |     }
 100 |     | 
 101 |     |     // Transfers to self should not break accounting
 102 | *   |     function test_ERC721_transferFromSelf() public virtual {
 103 | *   |         uint256 selfBalance = balanceOf(msg.sender);
 104 | *r  |         require(selfBalance > 0); 
 105 | *   |         uint tokenId = tokenOfOwnerByIndex(msg.sender, 0);
 106 |     | 
 107 | *   |         hevm.prank(msg.sender);
 108 | *   |         try IERC721(address(this)).transferFrom(msg.sender, msg.sender, tokenId) {
 109 | *   |             assertWithMsg(ownerOf(tokenId) == msg.sender, "Self transfer changes owner");
 110 | *   |             assertEq(balanceOf(msg.sender), selfBalance, "Self transfer breaks accounting");
 111 |     |         } catch {
 112 |     |             assertWithMsg(false, "transferFrom unexpectedly reverted");
 113 |     |         }
 114 |     |     }
 115 |     | 
 116 |     |     // Transfer to self reset approval
 117 | *   |     function test_ERC721_transferFromSelfResetsApproval() public virtual {
 118 | *   |         uint256 selfBalance = balanceOf(msg.sender);
 119 | *r  |         require(selfBalance > 0); 
 120 | *   |         uint tokenId = tokenOfOwnerByIndex(msg.sender, 0);
 121 |     | 
 122 | *   |         hevm.prank(msg.sender);
 123 | *   |         try IERC721(address(this)).transferFrom(msg.sender, msg.sender, tokenId) {
 124 | *   |             assertWithMsg(getApproved(tokenId) == address(0), "Self transfer does not reset approvals");
 125 |     |         } catch {
 126 |     |             assertWithMsg(false, "transferFrom unexpectedly reverted");
 127 |     |         }
 128 |     |     }
 129 |     | 
 130 |     |     // safeTransferFrom reverts if receiver does not implement the callback
 131 | *   |     function test_ERC721_safeTransferFromRevertsOnNoncontractReceiver(address target) public virtual {
 132 | *   |         uint256 selfBalance = balanceOf(msg.sender);
 133 | *r  |         require(selfBalance > 0); 
 134 | *r  |         require(target != address(this));
 135 | *r  |         require(target != msg.sender);
 136 | *   |         uint tokenId = tokenOfOwnerByIndex(msg.sender, 0);
 137 | *   |         require(ownerOf(tokenId) == msg.sender);
 138 |     |         
 139 | *   |         safeTransferFrom(msg.sender, address(unsafeReceiver), tokenId);
 140 |     |         assertWithMsg(false, "safeTransferFrom does not revert if receiver does not implement ERC721.onERC721Received");
 141 |     |     }
 142 |     | }
 143 |     | 

/home/ivruix/Desktop/hw4/lib/properties/contracts/ERC721/internal/properties/ERC721BurnableProperties.sol
   1 |     | pragma solidity ^0.8.13;
   2 |     | 
   3 |     | import "../util/ERC721TestBase.sol";
   4 |     | import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol";
   5 |     | 
   6 |     | 
   7 |     | abstract contract CryticERC721BurnableProperties is CryticERC721TestBase, ERC721Burnable {
   8 |     |     using Address for address;
   9 |     | 
  10 |     |     ////////////////////////////////////////
  11 |     |     // Properties
  12 |     | 
  13 |     |     // The burn function should destroy tokens and reduce the total supply
  14 | *   |     function test_ERC721_burnReducesTotalSupply() public virtual {
  15 | *   |         require(isMintableOrBurnable);
  16 | *   |         uint256 selfBalance = balanceOf(msg.sender);
  17 | *r  |         require(selfBalance > 0);
  18 |     | 
  19 | *   |         uint256 oldTotalSupply = totalSupply();
  20 | *   |         for(uint256 i; i < selfBalance; i++) {
  21 | *   |             uint256 tokenId = tokenOfOwnerByIndex(msg.sender, 0);
  22 | *   |             burn(tokenId);
  23 |     |         }
  24 |     | 
  25 | *   |         assertWithMsg(selfBalance <= oldTotalSupply, "Underflow - user balance larger than total supply");
  26 | *   |         assertEq(oldTotalSupply - selfBalance, totalSupply(), "Incorrect supply update on burn");
  27 |     |     }
  28 |     | 
  29 |     |     // A burned token should not be transferrable
  30 | *   |     function test_ERC721_burnRevertOnTransferFromPreviousOwner(address target) public virtual {
  31 | *   |         require(isMintableOrBurnable);
  32 | *   |         uint256 selfBalance = balanceOf(msg.sender);
  33 | *r  |         require(selfBalance > 0);
  34 |     | 
  35 | *   |         uint256 tokenId = tokenOfOwnerByIndex(msg.sender, 0);
  36 | *   |         burn(tokenId);
  37 | *   |         transferFrom(msg.sender, target, tokenId);
  38 |     |         assertWithMsg(false, "Transferring a burned token didn't revert");
  39 |     |     }
  40 |     | 
  41 | *   |     function test_ERC721_burnRevertOnTransferFromZeroAddress(address target) public virtual {
  42 | *   |         require(isMintableOrBurnable);
  43 | *   |         uint256 selfBalance = balanceOf(msg.sender);
  44 | *r  |         require(selfBalance > 0);
  45 |     | 
  46 | *   |         uint256 tokenId = tokenOfOwnerByIndex(msg.sender, 0);
  47 | *   |         burn(tokenId);
  48 | *   |         transferFrom(address(0), target, tokenId);
  49 |     |         assertWithMsg(false, "Transferring a burned token didn't revert");
  50 |     |     }
  51 |     | 
  52 | *   |     function test_ERC721_burnRevertOnApprove() public virtual {
  53 | *   |         require(isMintableOrBurnable);
  54 | *   |         uint256 selfBalance = balanceOf(msg.sender);
  55 | *r  |         require(selfBalance > 0);
  56 |     | 
  57 | *   |         uint256 tokenId = tokenOfOwnerByIndex(msg.sender, 0);
  58 | *   |         burn(tokenId);
  59 | *   |         approve(address(this), tokenId);
  60 |     |         assertWithMsg(false, "Approving a burned token didn't revert");
  61 |     |     }
  62 |     | 
  63 | *   |     function test_ERC721_burnRevertOnGetApproved() public virtual {
  64 | *   |         require(isMintableOrBurnable);
  65 | *   |         uint256 selfBalance = balanceOf(msg.sender);
  66 | *r  |         require(selfBalance > 0);
  67 |     | 
  68 | *   |         uint256 tokenId = tokenOfOwnerByIndex(msg.sender, 0);
  69 | *   |         burn(tokenId);
  70 | *   |         getApproved(tokenId);
  71 | *   |         assertWithMsg(false, "getApproved didn't revert for burned token");
  72 |     |     }
  73 |     | 
  74 | *   |     function test_ERC721_burnRevertOnOwnerOf() public virtual {
  75 | *   |         require(isMintableOrBurnable);
  76 | *   |         uint256 selfBalance = balanceOf(msg.sender);
  77 | *r  |         require(selfBalance > 0);
  78 |     | 
  79 | *   |         uint256 tokenId = tokenOfOwnerByIndex(msg.sender, 0);
  80 | *   |         burn(tokenId);
  81 | *   |         ownerOf(tokenId);
  82 | *   |         assertWithMsg(false, "ownerOf didn't revert for burned token");
  83 |     |     }
  84 |     | 
  85 |     |     // The following functions are overrides required by Solidity.
  86 |     | 
  87 | *   |     function _beforeTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize)
  88 |     |         internal
  89 |     |         virtual
  90 |     |         override(ERC721, CryticERC721TestBase)
  91 |     |     {
  92 | *o  |         super._beforeTokenTransfer(from, to, tokenId, batchSize);
  93 |     |     }
  94 |     | 
  95 | *   |     function supportsInterface(bytes4 interfaceId)
  96 |     |         public
  97 |     |         view
  98 |     |         virtual
  99 |     |         override(ERC721, CryticERC721TestBase)
 100 | *   |         returns (bool)
 101 |     |     {
 102 | *   |         return super.supportsInterface(interfaceId);
 103 |     |     }
 104 |     | }
 105 |     | 

/home/ivruix/Desktop/hw4/lib/properties/contracts/ERC721/internal/properties/ERC721MintableProperties.sol
  1 |     | pragma solidity ^0.8.13;
  2 |     | 
  3 |     | import "../util/ERC721TestBase.sol";
  4 |     | 
  5 |     | abstract contract CryticERC721MintableProperties is CryticERC721TestBase {
  6 |     | 
  7 |     | 
  8 |     |     ////////////////////////////////////////
  9 |     |     // Properties
 10 |     |     // mint increases the total supply.
 11 | *   |     function test_ERC721_mintIncreasesSupply(uint256 amount) public virtual {
 12 | *   |         require(isMintableOrBurnable);
 13 |     | 
 14 | *   |         uint256 selfBalance = balanceOf(msg.sender);
 15 | *   |         uint256 oldTotalSupply = totalSupply();
 16 | *   |         _customMint(msg.sender, amount);
 17 |     |         
 18 | *   |         assertEq(oldTotalSupply + amount, totalSupply(), "Total supply was not correctly increased");
 19 | *   |         assertEq(selfBalance + amount, balanceOf(msg.sender), "Receiver supply was not correctly increased");
 20 |     |     }
 21 |     | 
 22 |     |     // mint creates a fresh token.
 23 | *   |     function test_ERC721_mintCreatesFreshToken(uint256 amount) public virtual {
 24 | *   |         require(isMintableOrBurnable);
 25 |     | 
 26 | *   |         uint256 selfBalance = balanceOf(msg.sender);
 27 | *   |         _customMint(msg.sender, amount);
 28 |     | 
 29 | *   |         assertEq(selfBalance + amount, balanceOf(msg.sender), "Receiver supply was not correctly increased");
 30 |     | 
 31 | *   |         uint256 tokenId = tokenOfOwnerByIndex(msg.sender, selfBalance);
 32 | *   |         assertWithMsg(ownerOf(tokenId) == msg.sender, "Token ID was not minted to receiver");
 33 |     |         
 34 |     |     }
 35 |     | 
 36 |     |     // Wrappers
 37 |     |     function _customMint(address to, uint256 amount) internal virtual;
 38 |     | }
 39 |     | 

/home/ivruix/Desktop/hw4/lib/properties/contracts/ERC721/internal/util/ERC721TestBase.sol
  1 |     | pragma solidity ^0.8.0;
  2 |     | 
  3 |     | import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
  4 |     | import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
  5 |     | import "../../../util/PropertiesConstants.sol";
  6 |     | import "../../../util/PropertiesHelper.sol";
  7 |     | import {MockReceiver} from "./MockReceiver.sol";
  8 |     | import "../../../util/Hevm.sol";
  9 |     | 
 10 |     | abstract contract CryticERC721TestBase is ERC721, ERC721Enumerable, PropertiesAsserts, PropertiesConstants {
 11 |     | 
 12 |     |     // Is the contract allowed to change its total supply?
 13 |     |     bool isMintableOrBurnable;
 14 |     |     MockReceiver safeReceiver;
 15 |     |     MockReceiver unsafeReceiver;
 16 |     | 
 17 |     |     // The following functions are overrides required by Solidity.
 18 | *   |     function _beforeTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize)
 19 |     |         internal
 20 |     |         virtual
 21 |     |         override(ERC721, ERC721Enumerable)
 22 |     |     {
 23 | *   |         super._beforeTokenTransfer(from, to, tokenId, batchSize);
 24 |     |     }
 25 |     | 
 26 | *   |     function supportsInterface(bytes4 interfaceId)
 27 |     |         public
 28 |     |         view
 29 |     |         virtual
 30 |     |         override(ERC721, ERC721Enumerable)
 31 | *   |         returns (bool)
 32 |     |     {
 33 | *   |         return super.supportsInterface(interfaceId);
 34 |     |     }
 35 |     | }
 36 |     | 

/home/ivruix/Desktop/hw4/lib/properties/contracts/ERC721/internal/util/MockReceiver.sol
  1 |     | pragma solidity ^0.8.13;
  2 |     | 
  3 |     | import "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";
  4 |     | 
  5 |     | 
  6 | *   | contract MockReceiver is ERC721Holder {
  7 |     |     bool shouldReceive;
  8 |     | 
  9 | *   |     constructor(bool _shouldReceive) {
 10 | *   |         shouldReceive = _shouldReceive;
 11 |     |     }
 12 |     | 
 13 | *   |     function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {
 14 | *   |         if (shouldReceive) {
 15 |     |             return this.onERC721Received.selector;
 16 |     |         }
 17 |     | 
 18 | *   |         return bytes4(0);
 19 |     |     }
 20 |     | }

/home/ivruix/Desktop/hw4/lib/properties/contracts/util/Hevm.sol
  1 |     | // SPDX-License-Identifier: Unlicense
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | interface IHevm {
  5 |     |     // Set block.timestamp to newTimestamp
  6 |     |     function warp(uint256 newTimestamp) external;
  7 |     | 
  8 |     |     // Set block.number to newNumber
  9 |     |     function roll(uint256 newNumber) external;
 10 |     | 
 11 |     |     // Add the condition b to the assumption base for the current branch
 12 |     |     // This function is almost identical to require
 13 |     |     function assume(bool b) external;
 14 |     | 
 15 |     |     // Sets the eth balance of usr to amt
 16 |     |     function deal(address usr, uint256 amt) external;
 17 |     | 
 18 |     |     // Loads a storage slot from an address
 19 |     |     function load(address where, bytes32 slot) external returns (bytes32);
 20 |     | 
 21 |     |     // Stores a value to an address' storage slot
 22 |     |     function store(address where, bytes32 slot, bytes32 value) external;
 23 |     | 
 24 |     |     // Signs data (privateKey, digest) => (v, r, s)
 25 |     |     function sign(
 26 |     |         uint256 privateKey,
 27 |     |         bytes32 digest
 28 |     |     ) external returns (uint8 v, bytes32 r, bytes32 s);
 29 |     | 
 30 |     |     // Gets address for a given private key
 31 |     |     function addr(uint256 privateKey) external returns (address addr);
 32 |     | 
 33 |     |     // Performs a foreign function call via terminal
 34 |     |     function ffi(
 35 |     |         string[] calldata inputs
 36 |     |     ) external returns (bytes memory result);
 37 |     | 
 38 |     |     // Performs the next smart contract call with specified `msg.sender`
 39 |     |     function prank(address newSender) external;
 40 |     | 
 41 |     |     // Creates a new fork with the given endpoint and the latest block and returns the identifier of the fork
 42 |     |     function createFork(string calldata urlOrAlias) external returns (uint256);
 43 |     | 
 44 |     |     // Takes a fork identifier created by createFork and sets the corresponding forked state as active
 45 |     |     function selectFork(uint256 forkId) external;
 46 |     | 
 47 |     |     // Returns the identifier of the current fork
 48 |     |     function activeFork() external returns (uint256);
 49 |     | 
 50 |     |     // Labels the address in traces
 51 |     |     function label(address addr, string calldata label) external;
 52 |     | }
 53 |     | 
 54 | *   | IHevm constant hevm = IHevm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);
 55 |     | 

/home/ivruix/Desktop/hw4/lib/properties/contracts/util/PropertiesConstants.sol
  1 |     | pragma solidity ^0.8.0;
  2 |     | 
  3 |     | abstract contract PropertiesConstants {
  4 |     |     // Constant echidna addresses
  5 |     |     address constant USER1 = address(0x10000);
  6 |     |     address constant USER2 = address(0x20000);
  7 |     |     address constant USER3 = address(0x30000);
  8 |     |     uint256 constant INITIAL_BALANCE = 1000e18;
  9 |     | }
 10 |     | 

/home/ivruix/Desktop/hw4/lib/properties/contracts/util/PropertiesHelper.sol
   1 |     | pragma solidity ^0.8.0;
   2 |     | 
   3 |     | abstract contract PropertiesAsserts {
   4 |     |     event LogUint256(string, uint256);
   5 |     |     event LogAddress(string, address);
   6 |     |     event LogString(string);
   7 |     | 
   8 |     |     event AssertFail(string);
   9 |     |     event AssertEqFail(string);
  10 |     |     event AssertNeqFail(string);
  11 |     |     event AssertGteFail(string);
  12 |     |     event AssertGtFail(string);
  13 |     |     event AssertLteFail(string);
  14 |     |     event AssertLtFail(string);
  15 |     | 
  16 | *   |     function assertWithMsg(bool b, string memory reason) internal {
  17 | *   |         if (!b) {
  18 | *   |             emit AssertFail(reason);
  19 | *   |             assert(false);
  20 |     |         }
  21 |     |     }
  22 |     | 
  23 |     |     /// @notice asserts that a is equal to b. Violations are logged using reason.
  24 | *   |     function assertEq(uint256 a, uint256 b, string memory reason) internal {
  25 | *   |         if (a != b) {
  26 |     |             string memory aStr = PropertiesLibString.toString(a);
  27 |     |             string memory bStr = PropertiesLibString.toString(b);
  28 |     |             bytes memory assertMsg = abi.encodePacked(
  29 |     |                 "Invalid: ",
  30 |     |                 aStr,
  31 |     |                 "!=",
  32 |     |                 bStr,
  33 |     |                 ", reason: ",
  34 |     |                 reason
  35 |     |             );
  36 |     |             emit AssertEqFail(string(assertMsg));
  37 |     |             assert(false);
  38 |     |         }
  39 |     |     }
  40 |     | 
  41 |     |     /// @notice int256 version of assertEq
  42 |     |     function assertEq(int256 a, int256 b, string memory reason) internal {
  43 |     |         if (a != b) {
  44 |     |             string memory aStr = PropertiesLibString.toString(a);
  45 |     |             string memory bStr = PropertiesLibString.toString(b);
  46 |     |             bytes memory assertMsg = abi.encodePacked(
  47 |     |                 "Invalid: ",
  48 |     |                 aStr,
  49 |     |                 "!=",
  50 |     |                 bStr,
  51 |     |                 ", reason: ",
  52 |     |                 reason
  53 |     |             );
  54 |     |             emit AssertEqFail(string(assertMsg));
  55 |     |             assert(false);
  56 |     |         }
  57 |     |     }
  58 |     | 
  59 |     |     /// @notice asserts that a is not equal to b. Violations are logged using reason.
  60 |     |     function assertNeq(uint256 a, uint256 b, string memory reason) internal {
  61 |     |         if (a == b) {
  62 |     |             string memory aStr = PropertiesLibString.toString(a);
  63 |     |             string memory bStr = PropertiesLibString.toString(b);
  64 |     |             bytes memory assertMsg = abi.encodePacked(
  65 |     |                 "Invalid: ",
  66 |     |                 aStr,
  67 |     |                 "==",
  68 |     |                 bStr,
  69 |     |                 ", reason: ",
  70 |     |                 reason
  71 |     |             );
  72 |     |             emit AssertNeqFail(string(assertMsg));
  73 |     |             assert(false);
  74 |     |         }
  75 |     |     }
  76 |     | 
  77 |     |     /// @notice int256 version of assertNeq
  78 |     |     function assertNeq(int256 a, int256 b, string memory reason) internal {
  79 |     |         if (a == b) {
  80 |     |             string memory aStr = PropertiesLibString.toString(a);
  81 |     |             string memory bStr = PropertiesLibString.toString(b);
  82 |     |             bytes memory assertMsg = abi.encodePacked(
  83 |     |                 "Invalid: ",
  84 |     |                 aStr,
  85 |     |                 "==",
  86 |     |                 bStr,
  87 |     |                 ", reason: ",
  88 |     |                 reason
  89 |     |             );
  90 |     |             emit AssertNeqFail(string(assertMsg));
  91 |     |             assert(false);
  92 |     |         }
  93 |     |     }
  94 |     | 
  95 |     |     /// @notice asserts that a is greater than or equal to b. Violations are logged using reason.
  96 |     |     function assertGte(uint256 a, uint256 b, string memory reason) internal {
  97 |     |         if (!(a >= b)) {
  98 |     |             string memory aStr = PropertiesLibString.toString(a);
  99 |     |             string memory bStr = PropertiesLibString.toString(b);
 100 |     |             bytes memory assertMsg = abi.encodePacked(
 101 |     |                 "Invalid: ",
 102 |     |                 aStr,
 103 |     |                 "<",
 104 |     |                 bStr,
 105 |     |                 " failed, reason: ",
 106 |     |                 reason
 107 |     |             );
 108 |     |             emit AssertGteFail(string(assertMsg));
 109 |     |             assert(false);
 110 |     |         }
 111 |     |     }
 112 |     | 
 113 |     |     /// @notice int256 version of assertGte
 114 |     |     function assertGte(int256 a, int256 b, string memory reason) internal {
 115 |     |         if (!(a >= b)) {
 116 |     |             string memory aStr = PropertiesLibString.toString(a);
 117 |     |             string memory bStr = PropertiesLibString.toString(b);
 118 |     |             bytes memory assertMsg = abi.encodePacked(
 119 |     |                 "Invalid: ",
 120 |     |                 aStr,
 121 |     |                 "<",
 122 |     |                 bStr,
 123 |     |                 " failed, reason: ",
 124 |     |                 reason
 125 |     |             );
 126 |     |             emit AssertGteFail(string(assertMsg));
 127 |     |             assert(false);
 128 |     |         }
 129 |     |     }
 130 |     | 
 131 |     |     /// @notice asserts that a is greater than b. Violations are logged using reason.
 132 |     |     function assertGt(uint256 a, uint256 b, string memory reason) internal {
 133 |     |         if (!(a > b)) {
 134 |     |             string memory aStr = PropertiesLibString.toString(a);
 135 |     |             string memory bStr = PropertiesLibString.toString(b);
 136 |     |             bytes memory assertMsg = abi.encodePacked(
 137 |     |                 "Invalid: ",
 138 |     |                 aStr,
 139 |     |                 "<=",
 140 |     |                 bStr,
 141 |     |                 " failed, reason: ",
 142 |     |                 reason
 143 |     |             );
 144 |     |             emit AssertGtFail(string(assertMsg));
 145 |     |             assert(false);
 146 |     |         }
 147 |     |     }
 148 |     | 
 149 |     |     /// @notice int256 version of assertGt
 150 |     |     function assertGt(int256 a, int256 b, string memory reason) internal {
 151 |     |         if (!(a > b)) {
 152 |     |             string memory aStr = PropertiesLibString.toString(a);
 153 |     |             string memory bStr = PropertiesLibString.toString(b);
 154 |     |             bytes memory assertMsg = abi.encodePacked(
 155 |     |                 "Invalid: ",
 156 |     |                 aStr,
 157 |     |                 "<=",
 158 |     |                 bStr,
 159 |     |                 " failed, reason: ",
 160 |     |                 reason
 161 |     |             );
 162 |     |             emit AssertGtFail(string(assertMsg));
 163 |     |             assert(false);
 164 |     |         }
 165 |     |     }
 166 |     | 
 167 |     |     /// @notice asserts that a is less than or equal to b. Violations are logged using reason.
 168 |     |     function assertLte(uint256 a, uint256 b, string memory reason) internal {
 169 |     |         if (!(a <= b)) {
 170 |     |             string memory aStr = PropertiesLibString.toString(a);
 171 |     |             string memory bStr = PropertiesLibString.toString(b);
 172 |     |             bytes memory assertMsg = abi.encodePacked(
 173 |     |                 "Invalid: ",
 174 |     |                 aStr,
 175 |     |                 ">",
 176 |     |                 bStr,
 177 |     |                 " failed, reason: ",
 178 |     |                 reason
 179 |     |             );
 180 |     |             emit AssertLteFail(string(assertMsg));
 181 |     |             assert(false);
 182 |     |         }
 183 |     |     }
 184 |     | 
 185 |     |     /// @notice int256 version of assertLte
 186 |     |     function assertLte(int256 a, int256 b, string memory reason) internal {
 187 |     |         if (!(a <= b)) {
 188 |     |             string memory aStr = PropertiesLibString.toString(a);
 189 |     |             string memory bStr = PropertiesLibString.toString(b);
 190 |     |             bytes memory assertMsg = abi.encodePacked(
 191 |     |                 "Invalid: ",
 192 |     |                 aStr,
 193 |     |                 ">",
 194 |     |                 bStr,
 195 |     |                 " failed, reason: ",
 196 |     |                 reason
 197 |     |             );
 198 |     |             emit AssertLteFail(string(assertMsg));
 199 |     |             assert(false);
 200 |     |         }
 201 |     |     }
 202 |     | 
 203 |     |     /// @notice asserts that a is less than b. Violations are logged using reason.
 204 |     |     function assertLt(uint256 a, uint256 b, string memory reason) internal {
 205 |     |         if (!(a < b)) {
 206 |     |             string memory aStr = PropertiesLibString.toString(a);
 207 |     |             string memory bStr = PropertiesLibString.toString(b);
 208 |     |             bytes memory assertMsg = abi.encodePacked(
 209 |     |                 "Invalid: ",
 210 |     |                 aStr,
 211 |     |                 ">=",
 212 |     |                 bStr,
 213 |     |                 " failed, reason: ",
 214 |     |                 reason
 215 |     |             );
 216 |     |             emit AssertLtFail(string(assertMsg));
 217 |     |             assert(false);
 218 |     |         }
 219 |     |     }
 220 |     | 
 221 |     |     /// @notice int256 version of assertLt
 222 |     |     function assertLt(int256 a, int256 b, string memory reason) internal {
 223 |     |         if (!(a < b)) {
 224 |     |             string memory aStr = PropertiesLibString.toString(a);
 225 |     |             string memory bStr = PropertiesLibString.toString(b);
 226 |     |             bytes memory assertMsg = abi.encodePacked(
 227 |     |                 "Invalid: ",
 228 |     |                 aStr,
 229 |     |                 ">=",
 230 |     |                 bStr,
 231 |     |                 " failed, reason: ",
 232 |     |                 reason
 233 |     |             );
 234 |     |             emit AssertLtFail(string(assertMsg));
 235 |     |             assert(false);
 236 |     |         }
 237 |     |     }
 238 |     | 
 239 |     |     /// @notice Clamps value to be between low and high, both inclusive
 240 |     |     function clampBetween(
 241 |     |         uint256 value,
 242 |     |         uint256 low,
 243 |     |         uint256 high
 244 |     |     ) internal returns (uint256) {
 245 |     |         if (value < low || value > high) {
 246 |     |             uint ans = low + (value % (high - low + 1));
 247 |     |             string memory valueStr = PropertiesLibString.toString(value);
 248 |     |             string memory ansStr = PropertiesLibString.toString(ans);
 249 |     |             bytes memory message = abi.encodePacked(
 250 |     |                 "Clamping value ",
 251 |     |                 valueStr,
 252 |     |                 " to ",
 253 |     |                 ansStr
 254 |     |             );
 255 |     |             emit LogString(string(message));
 256 |     |             return ans;
 257 |     |         }
 258 |     |         return value;
 259 |     |     }
 260 |     | 
 261 |     |     /// @notice int256 version of clampBetween
 262 |     |     function clampBetween(
 263 |     |         int256 value,
 264 |     |         int256 low,
 265 |     |         int256 high
 266 |     |     ) internal returns (int256) {
 267 |     |         if (value < low || value > high) {
 268 |     |             int range = high - low + 1;
 269 |     |             int clamped = (value - low) % (range);
 270 |     |             if (clamped < 0) clamped += range;
 271 |     |             int ans = low + clamped;
 272 |     |             string memory valueStr = PropertiesLibString.toString(value);
 273 |     |             string memory ansStr = PropertiesLibString.toString(ans);
 274 |     |             bytes memory message = abi.encodePacked(
 275 |     |                 "Clamping value ",
 276 |     |                 valueStr,
 277 |     |                 " to ",
 278 |     |                 ansStr
 279 |     |             );
 280 |     |             emit LogString(string(message));
 281 |     |             return ans;
 282 |     |         }
 283 |     |         return value;
 284 |     |     }
 285 |     | 
 286 |     |     /// @notice clamps a to be less than b
 287 |     |     function clampLt(uint256 a, uint256 b) internal returns (uint256) {
 288 |     |         if (!(a < b)) {
 289 |     |             assertNeq(
 290 |     |                 b,
 291 |     |                 0,
 292 |     |                 "clampLt cannot clamp value a to be less than zero. Check your inputs/assumptions."
 293 |     |             );
 294 |     |             uint256 value = a % b;
 295 |     |             string memory aStr = PropertiesLibString.toString(a);
 296 |     |             string memory valueStr = PropertiesLibString.toString(value);
 297 |     |             bytes memory message = abi.encodePacked(
 298 |     |                 "Clamping value ",
 299 |     |                 aStr,
 300 |     |                 " to ",
 301 |     |                 valueStr
 302 |     |             );
 303 |     |             emit LogString(string(message));
 304 |     |             return value;
 305 |     |         }
 306 |     |         return a;
 307 |     |     }
 308 |     | 
 309 |     |     /// @notice int256 version of clampLt
 310 |     |     function clampLt(int256 a, int256 b) internal returns (int256) {
 311 |     |         if (!(a < b)) {
 312 |     |             int256 value = b - 1;
 313 |     |             string memory aStr = PropertiesLibString.toString(a);
 314 |     |             string memory valueStr = PropertiesLibString.toString(value);
 315 |     |             bytes memory message = abi.encodePacked(
 316 |     |                 "Clamping value ",
 317 |     |                 aStr,
 318 |     |                 " to ",
 319 |     |                 valueStr
 320 |     |             );
 321 |     |             emit LogString(string(message));
 322 |     |             return value;
 323 |     |         }
 324 |     |         return a;
 325 |     |     }
 326 |     | 
 327 |     |     /// @notice clamps a to be less than or equal to b
 328 |     |     function clampLte(uint256 a, uint256 b) internal returns (uint256) {
 329 |     |         if (!(a <= b)) {
 330 |     |             uint256 value = a % (b + 1);
 331 |     |             string memory aStr = PropertiesLibString.toString(a);
 332 |     |             string memory valueStr = PropertiesLibString.toString(value);
 333 |     |             bytes memory message = abi.encodePacked(
 334 |     |                 "Clamping value ",
 335 |     |                 aStr,
 336 |     |                 " to ",
 337 |     |                 valueStr
 338 |     |             );
 339 |     |             emit LogString(string(message));
 340 |     |             return value;
 341 |     |         }
 342 |     |         return a;
 343 |     |     }
 344 |     | 
 345 |     |     /// @notice int256 version of clampLte
 346 |     |     function clampLte(int256 a, int256 b) internal returns (int256) {
 347 |     |         if (!(a <= b)) {
 348 |     |             int256 value = b;
 349 |     |             string memory aStr = PropertiesLibString.toString(a);
 350 |     |             string memory valueStr = PropertiesLibString.toString(value);
 351 |     |             bytes memory message = abi.encodePacked(
 352 |     |                 "Clamping value ",
 353 |     |                 aStr,
 354 |     |                 " to ",
 355 |     |                 valueStr
 356 |     |             );
 357 |     |             emit LogString(string(message));
 358 |     |             return value;
 359 |     |         }
 360 |     |         return a;
 361 |     |     }
 362 |     | 
 363 |     |     /// @notice clamps a to be greater than b
 364 |     |     function clampGt(uint256 a, uint256 b) internal returns (uint256) {
 365 |     |         if (!(a > b)) {
 366 |     |             assertNeq(
 367 |     |                 b,
 368 |     |                 type(uint256).max,
 369 |     |                 "clampGt cannot clamp value a to be larger than uint256.max. Check your inputs/assumptions."
 370 |     |             );
 371 |     |             uint256 value = b + 1;
 372 |     |             string memory aStr = PropertiesLibString.toString(a);
 373 |     |             string memory valueStr = PropertiesLibString.toString(value);
 374 |     |             bytes memory message = abi.encodePacked(
 375 |     |                 "Clamping value ",
 376 |     |                 aStr,
 377 |     |                 " to ",
 378 |     |                 valueStr
 379 |     |             );
 380 |     |             emit LogString(string(message));
 381 |     |             return value;
 382 |     |         } else {
 383 |     |             return a;
 384 |     |         }
 385 |     |     }
 386 |     | 
 387 |     |     /// @notice int256 version of clampGt
 388 |     |     function clampGt(int256 a, int256 b) internal returns (int256) {
 389 |     |         if (!(a > b)) {
 390 |     |             int256 value = b + 1;
 391 |     |             string memory aStr = PropertiesLibString.toString(a);
 392 |     |             string memory valueStr = PropertiesLibString.toString(value);
 393 |     |             bytes memory message = abi.encodePacked(
 394 |     |                 "Clamping value ",
 395 |     |                 aStr,
 396 |     |                 " to ",
 397 |     |                 valueStr
 398 |     |             );
 399 |     |             emit LogString(string(message));
 400 |     |             return value;
 401 |     |         } else {
 402 |     |             return a;
 403 |     |         }
 404 |     |     }
 405 |     | 
 406 |     |     /// @notice clamps a to be greater than or equal to b
 407 |     |     function clampGte(uint256 a, uint256 b) internal returns (uint256) {
 408 |     |         if (!(a > b)) {
 409 |     |             uint256 value = b;
 410 |     |             string memory aStr = PropertiesLibString.toString(a);
 411 |     |             string memory valueStr = PropertiesLibString.toString(value);
 412 |     |             bytes memory message = abi.encodePacked(
 413 |     |                 "Clamping value ",
 414 |     |                 aStr,
 415 |     |                 " to ",
 416 |     |                 valueStr
 417 |     |             );
 418 |     |             emit LogString(string(message));
 419 |     |             return value;
 420 |     |         }
 421 |     |         return a;
 422 |     |     }
 423 |     | 
 424 |     |     /// @notice int256 version of clampGte
 425 |     |     function clampGte(int256 a, int256 b) internal returns (int256) {
 426 |     |         if (!(a > b)) {
 427 |     |             int256 value = b;
 428 |     |             string memory aStr = PropertiesLibString.toString(a);
 429 |     |             string memory valueStr = PropertiesLibString.toString(value);
 430 |     |             bytes memory message = abi.encodePacked(
 431 |     |                 "Clamping value ",
 432 |     |                 aStr,
 433 |     |                 " to ",
 434 |     |                 valueStr
 435 |     |             );
 436 |     |             emit LogString(string(message));
 437 |     |             return value;
 438 |     |         }
 439 |     |         return a;
 440 |     |     }
 441 |     | }
 442 |     | 
 443 |     | /// @notice Efficient library for creating string representations of integers.
 444 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)
 445 |     | /// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibString.sol)
 446 |     | /// @dev Name of the library is modified to prevent collisions with contract-under-test uses of LibString
 447 |     | library PropertiesLibString {
 448 |     |     function toString(int256 value) internal pure returns (string memory str) {
 449 |     |         uint256 absValue = value >= 0 ? uint256(value) : uint256(-value);
 450 |     |         str = toString(absValue);
 451 |     | 
 452 |     |         if (value < 0) {
 453 |     |             str = string(abi.encodePacked("-", str));
 454 |     |         }
 455 |     |     }
 456 |     | 
 457 |     |     function toString(uint256 value) internal pure returns (string memory str) {
 458 |     |         /// @solidity memory-safe-assembly
 459 |     |         assembly {
 460 |     |             // The maximum value of a uint256 contains 78 digits (1 byte per digit), but we allocate 160 bytes
 461 |     |             // to keep the free memory pointer word aligned. We'll need 1 word for the length, 1 word for the
 462 |     |             // trailing zeros padding, and 3 other words for a max of 78 digits. In total: 5 * 32 = 160 bytes.
 463 |     |             let newFreeMemoryPointer := add(mload(0x40), 160)
 464 |     | 
 465 |     |             // Update the free memory pointer to avoid overriding our string.
 466 |     |             mstore(0x40, newFreeMemoryPointer)
 467 |     | 
 468 |     |             // Assign str to the end of the zone of newly allocated memory.
 469 |     |             str := sub(newFreeMemoryPointer, 32)
 470 |     | 
 471 |     |             // Clean the last word of memory it may not be overwritten.
 472 |     |             mstore(str, 0)
 473 |     | 
 474 |     |             // Cache the end of the memory to calculate the length later.
 475 |     |             let end := str
 476 |     | 
 477 |     |             // We write the string from rightmost digit to leftmost digit.
 478 |     |             // The following is essentially a do-while loop that also handles the zero case.
 479 |     |             // prettier-ignore
 480 |     |             for { let temp := value } 1 {} {
 481 |     |                 // Move the pointer 1 byte to the left.
 482 |     |                 str := sub(str, 1)
 483 |     | 
 484 |     |                 // Write the character to the pointer.
 485 |     |                 // The ASCII index of the '0' character is 48.
 486 |     |                 mstore8(str, add(48, mod(temp, 10)))
 487 |     | 
 488 |     |                 // Keep dividing temp until zero.
 489 |     |                 temp := div(temp, 10)
 490 |     | 
 491 |     |                  // prettier-ignore
 492 |     |                 if iszero(temp) { break }
 493 |     |             }
 494 |     | 
 495 |     |             // Compute and cache the final total length of the string.
 496 |     |             let length := sub(end, str)
 497 |     | 
 498 |     |             // Move the pointer 32 bytes leftwards to make room for the length.
 499 |     |             str := sub(str, 32)
 500 |     | 
 501 |     |             // Store the string's length at the start of memory allocated for our string.
 502 |     |             mstore(str, length)
 503 |     |         }
 504 |     |     }
 505 |     | 
 506 |     |     function toString(address value) internal pure returns (string memory str) {
 507 |     |         bytes memory s = new bytes(40);
 508 |     |         for (uint i = 0; i < 20; i++) {
 509 |     |             bytes1 b = bytes1(
 510 |     |                 uint8(uint(uint160(value)) / (2 ** (8 * (19 - i))))
 511 |     |             );
 512 |     |             bytes1 hi = bytes1(uint8(b) / 16);
 513 |     |             bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));
 514 |     |             s[2 * i] = char(hi);
 515 |     |             s[2 * i + 1] = char(lo);
 516 |     |         }
 517 |     |         return string(s);
 518 |     |     }
 519 |     | 
 520 |     |     function char(bytes1 b) internal pure returns (bytes1 c) {
 521 |     |         if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);
 522 |     |         else return bytes1(uint8(b) + 0x57);
 523 |     |     }
 524 |     | }
 525 |     | 

/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/access/Ownable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../utils/Context.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Contract module which provides a basic access control mechanism, where
 10 |     |  * there is an account (an owner) that can be granted exclusive access to
 11 |     |  * specific functions.
 12 |     |  *
 13 |     |  * By default, the owner account will be the one that deploys the contract. This
 14 |     |  * can later be changed with {transferOwnership}.
 15 |     |  *
 16 |     |  * This module is used through inheritance. It will make available the modifier
 17 |     |  * `onlyOwner`, which can be applied to your functions to restrict their use to
 18 |     |  * the owner.
 19 |     |  */
 20 |     | abstract contract Ownable is Context {
 21 |     |     address private _owner;
 22 |     | 
 23 |     |     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
 24 |     | 
 25 |     |     /**
 26 |     |      * @dev Initializes the contract setting the deployer as the initial owner.
 27 |     |      */
 28 |     |     constructor() {
 29 | *   |         _transferOwnership(_msgSender());
 30 |     |     }
 31 |     | 
 32 |     |     /**
 33 |     |      * @dev Throws if called by any account other than the owner.
 34 |     |      */
 35 |     |     modifier onlyOwner() {
 36 | *   |         _checkOwner();
 37 |     |         _;
 38 |     |     }
 39 |     | 
 40 |     |     /**
 41 |     |      * @dev Returns the address of the current owner.
 42 |     |      */
 43 | *   |     function owner() public view virtual returns (address) {
 44 | *   |         return _owner;
 45 |     |     }
 46 |     | 
 47 |     |     /**
 48 |     |      * @dev Throws if the sender is not the owner.
 49 |     |      */
 50 | *   |     function _checkOwner() internal view virtual {
 51 | *   |         require(owner() == _msgSender(), "Ownable: caller is not the owner");
 52 |     |     }
 53 |     | 
 54 |     |     /**
 55 |     |      * @dev Leaves the contract without owner. It will not be possible to call
 56 |     |      * `onlyOwner` functions anymore. Can only be called by the current owner.
 57 |     |      *
 58 |     |      * NOTE: Renouncing ownership will leave the contract without an owner,
 59 |     |      * thereby removing any functionality that is only available to the owner.
 60 |     |      */
 61 | *   |     function renounceOwnership() public virtual onlyOwner {
 62 | *   |         _transferOwnership(address(0));
 63 |     |     }
 64 |     | 
 65 |     |     /**
 66 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
 67 |     |      * Can only be called by the current owner.
 68 |     |      */
 69 | *   |     function transferOwnership(address newOwner) public virtual onlyOwner {
 70 | *   |         require(newOwner != address(0), "Ownable: new owner is the zero address");
 71 | *   |         _transferOwnership(newOwner);
 72 |     |     }
 73 |     | 
 74 |     |     /**
 75 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
 76 |     |      * Internal function without access restriction.
 77 |     |      */
 78 | *   |     function _transferOwnership(address newOwner) internal virtual {
 79 | *   |         address oldOwner = _owner;
 80 | *   |         _owner = newOwner;
 81 | *   |         emit OwnershipTransferred(oldOwner, newOwner);
 82 |     |     }
 83 |     | }
 84 |     | 

/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/ERC721.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "./IERC721.sol";
   7 |     | import "./IERC721Receiver.sol";
   8 |     | import "./extensions/IERC721Metadata.sol";
   9 |     | import "../../utils/Address.sol";
  10 |     | import "../../utils/Context.sol";
  11 |     | import "../../utils/Strings.sol";
  12 |     | import "../../utils/introspection/ERC165.sol";
  13 |     | 
  14 |     | /**
  15 |     |  * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
  16 |     |  * the Metadata extension, but not including the Enumerable extension, which is available separately as
  17 |     |  * {ERC721Enumerable}.
  18 |     |  */
  19 |     | contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {
  20 |     |     using Address for address;
  21 |     |     using Strings for uint256;
  22 |     | 
  23 |     |     // Token name
  24 |     |     string private _name;
  25 |     | 
  26 |     |     // Token symbol
  27 |     |     string private _symbol;
  28 |     | 
  29 |     |     // Mapping from token ID to owner address
  30 | *   |     mapping(uint256 => address) public _owners;
  31 |     | 
  32 |     |     // Mapping owner address to token count
  33 | *   |     mapping(address => uint256) public _balances;
  34 |     | 
  35 |     |     // Mapping from token ID to approved address
  36 | *   |     mapping(uint256 => address) public _tokenApprovals;
  37 |     | 
  38 |     |     // Mapping from owner to operator approvals
  39 |     |     mapping(address => mapping(address => bool)) private _operatorApprovals;
  40 |     | 
  41 |     |     /**
  42 |     |      * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.
  43 |     |      */
  44 | *   |     constructor(string memory name_, string memory symbol_) {
  45 | *   |         _name = name_;
  46 | *   |         _symbol = symbol_;
  47 |     |     }
  48 |     | 
  49 |     |     /**
  50 |     |      * @dev See {IERC165-supportsInterface}.
  51 |     |      */
  52 | *   |     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
  53 |     |         return
  54 | *   |             interfaceId == type(IERC721).interfaceId ||
  55 | *   |             interfaceId == type(IERC721Metadata).interfaceId ||
  56 | *   |             super.supportsInterface(interfaceId);
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev See {IERC721-balanceOf}.
  61 |     |      */
  62 | *   |     function balanceOf(address owner) public view virtual override returns (uint256) {
  63 | *   |         require(owner != address(0), "ERC721: address zero is not a valid owner");
  64 | *   |         return _balances[owner];
  65 |     |     }
  66 |     | 
  67 |     |     /**
  68 |     |      * @dev See {IERC721-ownerOf}.
  69 |     |      */
  70 | *   |     function ownerOf(uint256 tokenId) public view virtual override returns (address) {
  71 |     |         address owner = _ownerOf(tokenId);
  72 | *   |         require(owner != address(0), "ERC721: invalid token ID");
  73 |     |         return owner;
  74 |     |     }
  75 |     | 
  76 |     |     /**
  77 |     |      * @dev See {IERC721Metadata-name}.
  78 |     |      */
  79 | *   |     function name() public view virtual override returns (string memory) {
  80 | *   |         return _name;
  81 |     |     }
  82 |     | 
  83 |     |     /**
  84 |     |      * @dev See {IERC721Metadata-symbol}.
  85 |     |      */
  86 | *   |     function symbol() public view virtual override returns (string memory) {
  87 | *   |         return _symbol;
  88 |     |     }
  89 |     | 
  90 |     |     /**
  91 |     |      * @dev See {IERC721Metadata-tokenURI}.
  92 |     |      */
  93 | *   |     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
  94 | *   |         _requireMinted(tokenId);
  95 |     | 
  96 |     |         string memory baseURI = _baseURI();
  97 | *   |         return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
  98 |     |     }
  99 |     | 
 100 |     |     /**
 101 |     |      * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
 102 |     |      * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
 103 |     |      * by default, can be overridden in child contracts.
 104 |     |      */
 105 |     |     function _baseURI() internal view virtual returns (string memory) {
 106 |     |         return "";
 107 |     |     }
 108 |     | 
 109 |     |     /**
 110 |     |      * @dev See {IERC721-approve}.
 111 |     |      */
 112 | *   |     function approve(address to, uint256 tokenId) public virtual override {
 113 | *   |         address owner = ERC721.ownerOf(tokenId);
 114 | *r  |         require(to != owner, "ERC721: approval to current owner");
 115 |     | 
 116 | *   |         require(
 117 | *   |             _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
 118 |     |             "ERC721: approve caller is not token owner or approved for all"
 119 |     |         );
 120 |     | 
 121 | *   |         _approve(to, tokenId);
 122 |     |     }
 123 |     | 
 124 |     |     /**
 125 |     |      * @dev See {IERC721-getApproved}.
 126 |     |      */
 127 | *   |     function getApproved(uint256 tokenId) public view virtual override returns (address) {
 128 | *   |         _requireMinted(tokenId);
 129 |     | 
 130 | *   |         return _tokenApprovals[tokenId];
 131 |     |     }
 132 |     | 
 133 |     |     /**
 134 |     |      * @dev See {IERC721-setApprovalForAll}.
 135 |     |      */
 136 | *   |     function setApprovalForAll(address operator, bool approved) public virtual override {
 137 | *   |         _setApprovalForAll(_msgSender(), operator, approved);
 138 |     |     }
 139 |     | 
 140 |     |     /**
 141 |     |      * @dev See {IERC721-isApprovedForAll}.
 142 |     |      */
 143 | *   |     function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
 144 | *   |         return _operatorApprovals[owner][operator];
 145 |     |     }
 146 |     | 
 147 |     |     /**
 148 |     |      * @dev See {IERC721-transferFrom}.
 149 |     |      */
 150 | *   |     function transferFrom(address from, address to, uint256 tokenId) public virtual override {
 151 |     |         //solhint-disable-next-line max-line-length
 152 | *   |         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");
 153 |     | 
 154 | *   |         _transfer(from, to, tokenId);
 155 |     |     }
 156 |     | 
 157 |     |     /**
 158 |     |      * @dev See {IERC721-safeTransferFrom}.
 159 |     |      */
 160 | *   |     function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {
 161 | *   |         safeTransferFrom(from, to, tokenId, "");
 162 |     |     }
 163 |     | 
 164 |     |     /**
 165 |     |      * @dev See {IERC721-safeTransferFrom}.
 166 |     |      */
 167 | *o  |     function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {
 168 | *   |         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");
 169 | *   |         _safeTransfer(from, to, tokenId, data);
 170 |     |     }
 171 |     | 
 172 |     |     /**
 173 |     |      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
 174 |     |      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
 175 |     |      *
 176 |     |      * `data` is additional data, it has no specified format and it is sent in call to `to`.
 177 |     |      *
 178 |     |      * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.
 179 |     |      * implement alternative mechanisms to perform token transfer, such as signature-based.
 180 |     |      *
 181 |     |      * Requirements:
 182 |     |      *
 183 |     |      * - `from` cannot be the zero address.
 184 |     |      * - `to` cannot be the zero address.
 185 |     |      * - `tokenId` token must exist and be owned by `from`.
 186 |     |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
 187 |     |      *
 188 |     |      * Emits a {Transfer} event.
 189 |     |      */
 190 | *   |     function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {
 191 | *   |         _transfer(from, to, tokenId);
 192 | *   |         require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");
 193 |     |     }
 194 |     | 
 195 |     |     /**
 196 |     |      * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist
 197 |     |      */
 198 | *   |     function _ownerOf(uint256 tokenId) internal view virtual returns (address) {
 199 | *o  |         return _owners[tokenId];
 200 |     |     }
 201 |     | 
 202 |     |     /**
 203 |     |      * @dev Returns whether `tokenId` exists.
 204 |     |      *
 205 |     |      * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
 206 |     |      *
 207 |     |      * Tokens start existing when they are minted (`_mint`),
 208 |     |      * and stop existing when they are burned (`_burn`).
 209 |     |      */
 210 | *   |     function _exists(uint256 tokenId) internal view virtual returns (bool) {
 211 | *   |         return _ownerOf(tokenId) != address(0);
 212 |     |     }
 213 |     | 
 214 |     |     /**
 215 |     |      * @dev Returns whether `spender` is allowed to manage `tokenId`.
 216 |     |      *
 217 |     |      * Requirements:
 218 |     |      *
 219 |     |      * - `tokenId` must exist.
 220 |     |      */
 221 | *   |     function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
 222 | *   |         address owner = ERC721.ownerOf(tokenId);
 223 | *   |         return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);
 224 |     |     }
 225 |     | 
 226 |     |     /**
 227 |     |      * @dev Safely mints `tokenId` and transfers it to `to`.
 228 |     |      *
 229 |     |      * Requirements:
 230 |     |      *
 231 |     |      * - `tokenId` must not exist.
 232 |     |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
 233 |     |      *
 234 |     |      * Emits a {Transfer} event.
 235 |     |      */
 236 |     |     function _safeMint(address to, uint256 tokenId) internal virtual {
 237 |     |         _safeMint(to, tokenId, "");
 238 |     |     }
 239 |     | 
 240 |     |     /**
 241 |     |      * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is
 242 |     |      * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.
 243 |     |      */
 244 |     |     function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {
 245 |     |         _mint(to, tokenId);
 246 |     |         require(
 247 |     |             _checkOnERC721Received(address(0), to, tokenId, data),
 248 |     |             "ERC721: transfer to non ERC721Receiver implementer"
 249 |     |         );
 250 |     |     }
 251 |     | 
 252 |     |     /**
 253 |     |      * @dev Mints `tokenId` and transfers it to `to`.
 254 |     |      *
 255 |     |      * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible
 256 |     |      *
 257 |     |      * Requirements:
 258 |     |      *
 259 |     |      * - `tokenId` must not exist.
 260 |     |      * - `to` cannot be the zero address.
 261 |     |      *
 262 |     |      * Emits a {Transfer} event.
 263 |     |      */
 264 | *   |     function _mint(address to, uint256 tokenId) internal virtual {
 265 | *   |         require(to != address(0), "ERC721: mint to the zero address");
 266 | *   |         require(!_exists(tokenId), "ERC721: token already minted");
 267 |     | 
 268 | *o  |         _beforeTokenTransfer(address(0), to, tokenId, 1);
 269 |     | 
 270 |     |         // Check that tokenId was not minted by `_beforeTokenTransfer` hook
 271 | *o  |         require(!_exists(tokenId), "ERC721: token already minted");
 272 |     | 
 273 |     |         unchecked {
 274 |     |             // Will not overflow unless all 2**256 token ids are minted to the same owner.
 275 |     |             // Given that tokens are minted one by one, it is impossible in practice that
 276 |     |             // this ever happens. Might change if we allow batch minting.
 277 |     |             // The ERC fails to describe this case.
 278 | *o  |             _balances[to] += 1;
 279 |     |         }
 280 |     | 
 281 | *o  |         _owners[tokenId] = to;
 282 |     | 
 283 | *o  |         emit Transfer(address(0), to, tokenId);
 284 |     | 
 285 |     |         _afterTokenTransfer(address(0), to, tokenId, 1);
 286 |     |     }
 287 |     | 
 288 |     |     /**
 289 |     |      * @dev Destroys `tokenId`.
 290 |     |      * The approval is cleared when the token is burned.
 291 |     |      * This is an internal function that does not check if the sender is authorized to operate on the token.
 292 |     |      *
 293 |     |      * Requirements:
 294 |     |      *
 295 |     |      * - `tokenId` must exist.
 296 |     |      *
 297 |     |      * Emits a {Transfer} event.
 298 |     |      */
 299 | *   |     function _burn(uint256 tokenId) internal virtual {
 300 | *   |         address owner = ERC721.ownerOf(tokenId);
 301 |     | 
 302 | *   |         _beforeTokenTransfer(owner, address(0), tokenId, 1);
 303 |     | 
 304 |     |         // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook
 305 | *   |         owner = ERC721.ownerOf(tokenId);
 306 |     | 
 307 |     |         // Clear approvals
 308 | *   |         delete _tokenApprovals[tokenId];
 309 |     | 
 310 |     |         unchecked {
 311 |     |             // Cannot overflow, as that would require more tokens to be burned/transferred
 312 |     |             // out than the owner initially received through minting and transferring in.
 313 | *   |             _balances[owner] -= 1;
 314 |     |         }
 315 | *   |         delete _owners[tokenId];
 316 |     | 
 317 | *   |         emit Transfer(owner, address(0), tokenId);
 318 |     | 
 319 |     |         _afterTokenTransfer(owner, address(0), tokenId, 1);
 320 |     |     }
 321 |     | 
 322 |     |     /**
 323 |     |      * @dev Transfers `tokenId` from `from` to `to`.
 324 |     |      *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
 325 |     |      *
 326 |     |      * Requirements:
 327 |     |      *
 328 |     |      * - `to` cannot be the zero address.
 329 |     |      * - `tokenId` token must be owned by `from`.
 330 |     |      *
 331 |     |      * Emits a {Transfer} event.
 332 |     |      */
 333 |     |     function _transfer(address from, address to, uint256 tokenId) internal virtual {
 334 |     |         require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");
 335 |     |         require(to != address(0), "ERC721: transfer to the zero address");
 336 |     | 
 337 |     |         _beforeTokenTransfer(from, to, tokenId, 1);
 338 |     | 
 339 |     |         // Check that tokenId was not transferred by `_beforeTokenTransfer` hook
 340 |     |         require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");
 341 |     | 
 342 |     |         // Clear approvals from the previous owner
 343 |     |         delete _tokenApprovals[tokenId];
 344 |     | 
 345 |     |         unchecked {
 346 |     |             // `_balances[from]` cannot overflow for the same reason as described in `_burn`:
 347 |     |             // `from`'s balance is the number of token held, which is at least one before the current
 348 |     |             // transfer.
 349 |     |             // `_balances[to]` could overflow in the conditions described in `_mint`. That would require
 350 |     |             // all 2**256 token ids to be minted, which in practice is impossible.
 351 |     |             _balances[from] -= 1;
 352 |     |             _balances[to] += 1;
 353 |     |         }
 354 |     |         _owners[tokenId] = to;
 355 |     | 
 356 |     |         emit Transfer(from, to, tokenId);
 357 |     | 
 358 |     |         _afterTokenTransfer(from, to, tokenId, 1);
 359 |     |     }
 360 |     | 
 361 |     |     /**
 362 |     |      * @dev Approve `to` to operate on `tokenId`
 363 |     |      *
 364 |     |      * Emits an {Approval} event.
 365 |     |      */
 366 | *   |     function _approve(address to, uint256 tokenId) internal virtual {
 367 | *   |         _tokenApprovals[tokenId] = to;
 368 | *   |         emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
 369 |     |     }
 370 |     | 
 371 |     |     /**
 372 |     |      * @dev Approve `operator` to operate on all of `owner` tokens
 373 |     |      *
 374 |     |      * Emits an {ApprovalForAll} event.
 375 |     |      */
 376 | *   |     function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {
 377 | *   |         require(owner != operator, "ERC721: approve to caller");
 378 | *   |         _operatorApprovals[owner][operator] = approved;
 379 | *   |         emit ApprovalForAll(owner, operator, approved);
 380 |     |     }
 381 |     | 
 382 |     |     /**
 383 |     |      * @dev Reverts if the `tokenId` has not been minted yet.
 384 |     |      */
 385 | *   |     function _requireMinted(uint256 tokenId) internal view virtual {
 386 | *   |         require(_exists(tokenId), "ERC721: invalid token ID");
 387 |     |     }
 388 |     | 
 389 |     |     /**
 390 |     |      * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
 391 |     |      * The call is not executed if the target address is not a contract.
 392 |     |      *
 393 |     |      * @param from address representing the previous owner of the given token ID
 394 |     |      * @param to target address that will receive the tokens
 395 |     |      * @param tokenId uint256 ID of the token to be transferred
 396 |     |      * @param data bytes optional data to send along with the call
 397 |     |      * @return bool whether the call correctly returned the expected magic value
 398 |     |      */
 399 | *   |     function _checkOnERC721Received(
 400 |     |         address from,
 401 |     |         address to,
 402 |     |         uint256 tokenId,
 403 |     |         bytes memory data
 404 | *   |     ) private returns (bool) {
 405 | *   |         if (to.isContract()) {
 406 | *   |             try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {
 407 | *   |                 return retval == IERC721Receiver.onERC721Received.selector;
 408 |     |             } catch (bytes memory reason) {
 409 |     |                 if (reason.length == 0) {
 410 |     |                     revert("ERC721: transfer to non ERC721Receiver implementer");
 411 |     |                 } else {
 412 |     |                     /// @solidity memory-safe-assembly
 413 |     |                     assembly {
 414 |     |                         revert(add(32, reason), mload(reason))
 415 |     |                     }
 416 |     |                 }
 417 |     |             }
 418 |     |         } else {
 419 |     |             return true;
 420 |     |         }
 421 |     |     }
 422 |     | 
 423 |     |     /**
 424 |     |      * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is
 425 |     |      * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.
 426 |     |      *
 427 |     |      * Calling conditions:
 428 |     |      *
 429 |     |      * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.
 430 |     |      * - When `from` is zero, the tokens will be minted for `to`.
 431 |     |      * - When `to` is zero, ``from``'s tokens will be burned.
 432 |     |      * - `from` and `to` are never both zero.
 433 |     |      * - `batchSize` is non-zero.
 434 |     |      *
 435 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 436 |     |      */
 437 | *   |     function _beforeTokenTransfer(
 438 |     |         address from,
 439 |     |         address to,
 440 |     |         uint256 /* firstTokenId */,
 441 |     |         uint256 batchSize
 442 |     |     ) internal virtual {
 443 | *   |         if (batchSize > 1) {
 444 |     |             if (from != address(0)) {
 445 |     |                 _balances[from] -= batchSize;
 446 |     |             }
 447 |     |             if (to != address(0)) {
 448 |     |                 _balances[to] += batchSize;
 449 |     |             }
 450 |     |         }
 451 |     |     }
 452 |     | 
 453 |     |     /**
 454 |     |      * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is
 455 |     |      * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.
 456 |     |      *
 457 |     |      * Calling conditions:
 458 |     |      *
 459 |     |      * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.
 460 |     |      * - When `from` is zero, the tokens were minted for `to`.
 461 |     |      * - When `to` is zero, ``from``'s tokens were burned.
 462 |     |      * - `from` and `to` are never both zero.
 463 |     |      * - `batchSize` is non-zero.
 464 |     |      *
 465 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 466 |     |      */
 467 |     |     function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}
 468 |     | }
 469 |     | 

/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "../../utils/introspection/IERC165.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Required interface of an ERC721 compliant contract.
  10 |     |  */
  11 |     | interface IERC721 is IERC165 {
  12 |     |     /**
  13 |     |      * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
  14 |     |      */
  15 |     |     event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
  16 |     | 
  17 |     |     /**
  18 |     |      * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
  19 |     |      */
  20 |     |     event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
  24 |     |      */
  25 |     |     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
  26 |     | 
  27 |     |     /**
  28 |     |      * @dev Returns the number of tokens in ``owner``'s account.
  29 |     |      */
  30 |     |     function balanceOf(address owner) external view returns (uint256 balance);
  31 |     | 
  32 |     |     /**
  33 |     |      * @dev Returns the owner of the `tokenId` token.
  34 |     |      *
  35 |     |      * Requirements:
  36 |     |      *
  37 |     |      * - `tokenId` must exist.
  38 |     |      */
  39 |     |     function ownerOf(uint256 tokenId) external view returns (address owner);
  40 |     | 
  41 |     |     /**
  42 |     |      * @dev Safely transfers `tokenId` token from `from` to `to`.
  43 |     |      *
  44 |     |      * Requirements:
  45 |     |      *
  46 |     |      * - `from` cannot be the zero address.
  47 |     |      * - `to` cannot be the zero address.
  48 |     |      * - `tokenId` token must exist and be owned by `from`.
  49 |     |      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
  50 |     |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
  51 |     |      *
  52 |     |      * Emits a {Transfer} event.
  53 |     |      */
  54 |     |     function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
  55 |     | 
  56 |     |     /**
  57 |     |      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
  58 |     |      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
  59 |     |      *
  60 |     |      * Requirements:
  61 |     |      *
  62 |     |      * - `from` cannot be the zero address.
  63 |     |      * - `to` cannot be the zero address.
  64 |     |      * - `tokenId` token must exist and be owned by `from`.
  65 |     |      * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.
  66 |     |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
  67 |     |      *
  68 |     |      * Emits a {Transfer} event.
  69 |     |      */
  70 |     |     function safeTransferFrom(address from, address to, uint256 tokenId) external;
  71 |     | 
  72 |     |     /**
  73 |     |      * @dev Transfers `tokenId` token from `from` to `to`.
  74 |     |      *
  75 |     |      * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721
  76 |     |      * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must
  77 |     |      * understand this adds an external call which potentially creates a reentrancy vulnerability.
  78 |     |      *
  79 |     |      * Requirements:
  80 |     |      *
  81 |     |      * - `from` cannot be the zero address.
  82 |     |      * - `to` cannot be the zero address.
  83 |     |      * - `tokenId` token must be owned by `from`.
  84 |     |      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
  85 |     |      *
  86 |     |      * Emits a {Transfer} event.
  87 |     |      */
  88 |     |     function transferFrom(address from, address to, uint256 tokenId) external;
  89 |     | 
  90 |     |     /**
  91 |     |      * @dev Gives permission to `to` to transfer `tokenId` token to another account.
  92 |     |      * The approval is cleared when the token is transferred.
  93 |     |      *
  94 |     |      * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
  95 |     |      *
  96 |     |      * Requirements:
  97 |     |      *
  98 |     |      * - The caller must own the token or be an approved operator.
  99 |     |      * - `tokenId` must exist.
 100 |     |      *
 101 |     |      * Emits an {Approval} event.
 102 |     |      */
 103 |     |     function approve(address to, uint256 tokenId) external;
 104 |     | 
 105 |     |     /**
 106 |     |      * @dev Approve or remove `operator` as an operator for the caller.
 107 |     |      * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
 108 |     |      *
 109 |     |      * Requirements:
 110 |     |      *
 111 |     |      * - The `operator` cannot be the caller.
 112 |     |      *
 113 |     |      * Emits an {ApprovalForAll} event.
 114 |     |      */
 115 |     |     function setApprovalForAll(address operator, bool approved) external;
 116 |     | 
 117 |     |     /**
 118 |     |      * @dev Returns the account approved for `tokenId` token.
 119 |     |      *
 120 |     |      * Requirements:
 121 |     |      *
 122 |     |      * - `tokenId` must exist.
 123 |     |      */
 124 |     |     function getApproved(uint256 tokenId) external view returns (address operator);
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
 128 |     |      *
 129 |     |      * See {setApprovalForAll}
 130 |     |      */
 131 |     |     function isApprovedForAll(address owner, address operator) external view returns (bool);
 132 |     | }
 133 |     | 

/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @title ERC721 token receiver interface
  8 |     |  * @dev Interface for any contract that wants to support safeTransfers
  9 |     |  * from ERC721 asset contracts.
 10 |     |  */
 11 |     | interface IERC721Receiver {
 12 |     |     /**
 13 |     |      * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
 14 |     |      * by `operator` from `from`, this function is called.
 15 |     |      *
 16 |     |      * It must return its Solidity selector to confirm the token transfer.
 17 |     |      * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
 18 |     |      *
 19 |     |      * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.
 20 |     |      */
 21 |     |     function onERC721Received(
 22 |     |         address operator,
 23 |     |         address from,
 24 |     |         uint256 tokenId,
 25 |     |         bytes calldata data
 26 |     |     ) external returns (bytes4);
 27 |     | }
 28 |     | 

/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/token/ERC721/extensions/ERC721Burnable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Burnable.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../ERC721.sol";
  7 |     | import "../../../utils/Context.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @title ERC721 Burnable Token
 11 |     |  * @dev ERC721 Token that can be burned (destroyed).
 12 |     |  */
 13 |     | abstract contract ERC721Burnable is Context, ERC721 {
 14 |     |     /**
 15 |     |      * @dev Burns `tokenId`. See {ERC721-_burn}.
 16 |     |      *
 17 |     |      * Requirements:
 18 |     |      *
 19 |     |      * - The caller must own `tokenId` or be an approved operator.
 20 |     |      */
 21 | *   |     function burn(uint256 tokenId) public virtual {
 22 |     |         //solhint-disable-next-line max-line-length
 23 | *   |         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");
 24 | *   |         _burn(tokenId);
 25 |     |     }
 26 |     | }
 27 |     | 

/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/token/ERC721/extensions/ERC721Enumerable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Enumerable.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "../ERC721.sol";
   7 |     | import "./IERC721Enumerable.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @dev This implements an optional extension of {ERC721} defined in the EIP that adds
  11 |     |  * enumerability of all the token ids in the contract as well as all token ids owned by each
  12 |     |  * account.
  13 |     |  */
  14 |     | abstract contract ERC721Enumerable is ERC721, IERC721Enumerable {
  15 |     |     // Mapping from owner to list of owned token IDs
  16 |     |     mapping(address => mapping(uint256 => uint256)) private _ownedTokens;
  17 |     | 
  18 |     |     // Mapping from token ID to index of the owner tokens list
  19 |     |     mapping(uint256 => uint256) private _ownedTokensIndex;
  20 |     | 
  21 |     |     // Array with all token ids, used for enumeration
  22 |     |     uint256[] private _allTokens;
  23 |     | 
  24 |     |     // Mapping from token id to position in the allTokens array
  25 |     |     mapping(uint256 => uint256) private _allTokensIndex;
  26 |     | 
  27 |     |     /**
  28 |     |      * @dev See {IERC165-supportsInterface}.
  29 |     |      */
  30 | *   |     function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {
  31 | *   |         return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);
  32 |     |     }
  33 |     | 
  34 |     |     /**
  35 |     |      * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.
  36 |     |      */
  37 | *   |     function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {
  38 | *   |         require(index < ERC721.balanceOf(owner), "ERC721Enumerable: owner index out of bounds");
  39 | *   |         return _ownedTokens[owner][index];
  40 |     |     }
  41 |     | 
  42 |     |     /**
  43 |     |      * @dev See {IERC721Enumerable-totalSupply}.
  44 |     |      */
  45 | *   |     function totalSupply() public view virtual override returns (uint256) {
  46 | *   |         return _allTokens.length;
  47 |     |     }
  48 |     | 
  49 |     |     /**
  50 |     |      * @dev See {IERC721Enumerable-tokenByIndex}.
  51 |     |      */
  52 | *   |     function tokenByIndex(uint256 index) public view virtual override returns (uint256) {
  53 | *   |         require(index < ERC721Enumerable.totalSupply(), "ERC721Enumerable: global index out of bounds");
  54 |     |         return _allTokens[index];
  55 |     |     }
  56 |     | 
  57 |     |     /**
  58 |     |      * @dev See {ERC721-_beforeTokenTransfer}.
  59 |     |      */
  60 | *   |     function _beforeTokenTransfer(
  61 |     |         address from,
  62 |     |         address to,
  63 |     |         uint256 firstTokenId,
  64 |     |         uint256 batchSize
  65 | *   |     ) internal virtual override {
  66 | *   |         super._beforeTokenTransfer(from, to, firstTokenId, batchSize);
  67 |     | 
  68 | *   |         if (batchSize > 1) {
  69 |     |             // Will only trigger during construction. Batch transferring (minting) is not available afterwards.
  70 |     |             revert("ERC721Enumerable: consecutive transfers not supported");
  71 |     |         }
  72 |     | 
  73 | *   |         uint256 tokenId = firstTokenId;
  74 |     | 
  75 | *   |         if (from == address(0)) {
  76 | *   |             _addTokenToAllTokensEnumeration(tokenId);
  77 | *   |         } else if (from != to) {
  78 | *   |             _removeTokenFromOwnerEnumeration(from, tokenId);
  79 |     |         }
  80 | *   |         if (to == address(0)) {
  81 | *   |             _removeTokenFromAllTokensEnumeration(tokenId);
  82 | *   |         } else if (to != from) {
  83 | *   |             _addTokenToOwnerEnumeration(to, tokenId);
  84 |     |         }
  85 |     |     }
  86 |     | 
  87 |     |     /**
  88 |     |      * @dev Private function to add a token to this extension's ownership-tracking data structures.
  89 |     |      * @param to address representing the new owner of the given token ID
  90 |     |      * @param tokenId uint256 ID of the token to be added to the tokens list of the given address
  91 |     |      */
  92 | *   |     function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {
  93 | *   |         uint256 length = ERC721.balanceOf(to);
  94 | *o  |         _ownedTokens[to][length] = tokenId;
  95 | *o  |         _ownedTokensIndex[tokenId] = length;
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @dev Private function to add a token to this extension's token tracking data structures.
 100 |     |      * @param tokenId uint256 ID of the token to be added to the tokens list
 101 |     |      */
 102 | *   |     function _addTokenToAllTokensEnumeration(uint256 tokenId) private {
 103 | *o  |         _allTokensIndex[tokenId] = _allTokens.length;
 104 | *o  |         _allTokens.push(tokenId);
 105 |     |     }
 106 |     | 
 107 |     |     /**
 108 |     |      * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that
 109 |     |      * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for
 110 |     |      * gas optimizations e.g. when performing a transfer operation (avoiding double writes).
 111 |     |      * This has O(1) time complexity, but alters the order of the _ownedTokens array.
 112 |     |      * @param from address representing the previous owner of the given token ID
 113 |     |      * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address
 114 |     |      */
 115 | *   |     function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {
 116 |     |         // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and
 117 |     |         // then delete the last slot (swap and pop).
 118 |     | 
 119 | *   |         uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;
 120 | *   |         uint256 tokenIndex = _ownedTokensIndex[tokenId];
 121 |     | 
 122 |     |         // When the token to delete is the last token, the swap operation is unnecessary
 123 | *   |         if (tokenIndex != lastTokenIndex) {
 124 | *   |             uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];
 125 |     | 
 126 | *   |             _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token
 127 | *   |             _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index
 128 |     |         }
 129 |     | 
 130 |     |         // This also deletes the contents at the last position of the array
 131 | *   |         delete _ownedTokensIndex[tokenId];
 132 | *   |         delete _ownedTokens[from][lastTokenIndex];
 133 |     |     }
 134 |     | 
 135 |     |     /**
 136 |     |      * @dev Private function to remove a token from this extension's token tracking data structures.
 137 |     |      * This has O(1) time complexity, but alters the order of the _allTokens array.
 138 |     |      * @param tokenId uint256 ID of the token to be removed from the tokens list
 139 |     |      */
 140 | *   |     function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {
 141 |     |         // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and
 142 |     |         // then delete the last slot (swap and pop).
 143 |     | 
 144 | *   |         uint256 lastTokenIndex = _allTokens.length - 1;
 145 | *   |         uint256 tokenIndex = _allTokensIndex[tokenId];
 146 |     | 
 147 |     |         // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so
 148 |     |         // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding
 149 |     |         // an 'if' statement (like in _removeTokenFromOwnerEnumeration)
 150 | *   |         uint256 lastTokenId = _allTokens[lastTokenIndex];
 151 |     | 
 152 | *   |         _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token
 153 | *   |         _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index
 154 |     | 
 155 |     |         // This also deletes the contents at the last position of the array
 156 | *   |         delete _allTokensIndex[tokenId];
 157 | *   |         _allTokens.pop();
 158 |     |     }
 159 |     | }
 160 |     | 

/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Enumerable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../IERC721.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension
 10 |     |  * @dev See https://eips.ethereum.org/EIPS/eip-721
 11 |     |  */
 12 |     | interface IERC721Enumerable is IERC721 {
 13 |     |     /**
 14 |     |      * @dev Returns the total amount of tokens stored by the contract.
 15 |     |      */
 16 |     |     function totalSupply() external view returns (uint256);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Returns a token ID owned by `owner` at a given `index` of its token list.
 20 |     |      * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.
 21 |     |      */
 22 |     |     function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.
 26 |     |      * Use along with {totalSupply} to enumerate all tokens.
 27 |     |      */
 28 |     |     function tokenByIndex(uint256 index) external view returns (uint256);
 29 |     | }
 30 |     | 

/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../IERC721.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
 10 |     |  * @dev See https://eips.ethereum.org/EIPS/eip-721
 11 |     |  */
 12 |     | interface IERC721Metadata is IERC721 {
 13 |     |     /**
 14 |     |      * @dev Returns the token collection name.
 15 |     |      */
 16 |     |     function name() external view returns (string memory);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Returns the token collection symbol.
 20 |     |      */
 21 |     |     function symbol() external view returns (string memory);
 22 |     | 
 23 |     |     /**
 24 |     |      * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
 25 |     |      */
 26 |     |     function tokenURI(uint256 tokenId) external view returns (string memory);
 27 |     | }
 28 |     | 

/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/token/ERC721/utils/ERC721Holder.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../IERC721Receiver.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Implementation of the {IERC721Receiver} interface.
 10 |     |  *
 11 |     |  * Accepts all token transfers.
 12 |     |  * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.
 13 |     |  */
 14 |     | contract ERC721Holder is IERC721Receiver {
 15 |     |     /**
 16 |     |      * @dev See {IERC721Receiver-onERC721Received}.
 17 |     |      *
 18 |     |      * Always returns `IERC721Receiver.onERC721Received.selector`.
 19 |     |      */
 20 |     |     function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {
 21 |     |         return this.onERC721Received.selector;
 22 |     |     }
 23 |     | }
 24 |     | 

/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/utils/Address.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.1;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Collection of functions related to the address type
   8 |     |  */
   9 |     | library Address {
  10 |     |     /**
  11 |     |      * @dev Returns true if `account` is a contract.
  12 |     |      *
  13 |     |      * [IMPORTANT]
  14 |     |      * ====
  15 |     |      * It is unsafe to assume that an address for which this function returns
  16 |     |      * false is an externally-owned account (EOA) and not a contract.
  17 |     |      *
  18 |     |      * Among others, `isContract` will return false for the following
  19 |     |      * types of addresses:
  20 |     |      *
  21 |     |      *  - an externally-owned account
  22 |     |      *  - a contract in construction
  23 |     |      *  - an address where a contract will be created
  24 |     |      *  - an address where a contract lived, but was destroyed
  25 |     |      *
  26 |     |      * Furthermore, `isContract` will also return true if the target contract within
  27 |     |      * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,
  28 |     |      * which only has an effect at the end of a transaction.
  29 |     |      * ====
  30 |     |      *
  31 |     |      * [IMPORTANT]
  32 |     |      * ====
  33 |     |      * You shouldn't rely on `isContract` to protect against flash loan attacks!
  34 |     |      *
  35 |     |      * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
  36 |     |      * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
  37 |     |      * constructor.
  38 |     |      * ====
  39 |     |      */
  40 |     |     function isContract(address account) internal view returns (bool) {
  41 |     |         // This method relies on extcodesize/address.code.length, which returns 0
  42 |     |         // for contracts in construction, since the code is only stored at the end
  43 |     |         // of the constructor execution.
  44 |     | 
  45 | *   |         return account.code.length > 0;
  46 |     |     }
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
  50 |     |      * `recipient`, forwarding all available gas and reverting on errors.
  51 |     |      *
  52 |     |      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
  53 |     |      * of certain opcodes, possibly making contracts go over the 2300 gas limit
  54 |     |      * imposed by `transfer`, making them unable to receive funds via
  55 |     |      * `transfer`. {sendValue} removes this limitation.
  56 |     |      *
  57 |     |      * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].
  58 |     |      *
  59 |     |      * IMPORTANT: because control is transferred to `recipient`, care must be
  60 |     |      * taken to not create reentrancy vulnerabilities. Consider using
  61 |     |      * {ReentrancyGuard} or the
  62 |     |      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
  63 |     |      */
  64 |     |     function sendValue(address payable recipient, uint256 amount) internal {
  65 |     |         require(address(this).balance >= amount, "Address: insufficient balance");
  66 |     | 
  67 |     |         (bool success, ) = recipient.call{value: amount}("");
  68 |     |         require(success, "Address: unable to send value, recipient may have reverted");
  69 |     |     }
  70 |     | 
  71 |     |     /**
  72 |     |      * @dev Performs a Solidity function call using a low level `call`. A
  73 |     |      * plain `call` is an unsafe replacement for a function call: use this
  74 |     |      * function instead.
  75 |     |      *
  76 |     |      * If `target` reverts with a revert reason, it is bubbled up by this
  77 |     |      * function (like regular Solidity function calls).
  78 |     |      *
  79 |     |      * Returns the raw returned data. To convert to the expected return value,
  80 |     |      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
  81 |     |      *
  82 |     |      * Requirements:
  83 |     |      *
  84 |     |      * - `target` must be a contract.
  85 |     |      * - calling `target` with `data` must not revert.
  86 |     |      *
  87 |     |      * _Available since v3.1._
  88 |     |      */
  89 |     |     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
  90 |     |         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
  91 |     |     }
  92 |     | 
  93 |     |     /**
  94 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
  95 |     |      * `errorMessage` as a fallback revert reason when `target` reverts.
  96 |     |      *
  97 |     |      * _Available since v3.1._
  98 |     |      */
  99 |     |     function functionCall(
 100 |     |         address target,
 101 |     |         bytes memory data,
 102 |     |         string memory errorMessage
 103 |     |     ) internal returns (bytes memory) {
 104 |     |         return functionCallWithValue(target, data, 0, errorMessage);
 105 |     |     }
 106 |     | 
 107 |     |     /**
 108 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 109 |     |      * but also transferring `value` wei to `target`.
 110 |     |      *
 111 |     |      * Requirements:
 112 |     |      *
 113 |     |      * - the calling contract must have an ETH balance of at least `value`.
 114 |     |      * - the called Solidity function must be `payable`.
 115 |     |      *
 116 |     |      * _Available since v3.1._
 117 |     |      */
 118 |     |     function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
 119 |     |         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
 120 |     |     }
 121 |     | 
 122 |     |     /**
 123 |     |      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
 124 |     |      * with `errorMessage` as a fallback revert reason when `target` reverts.
 125 |     |      *
 126 |     |      * _Available since v3.1._
 127 |     |      */
 128 |     |     function functionCallWithValue(
 129 |     |         address target,
 130 |     |         bytes memory data,
 131 |     |         uint256 value,
 132 |     |         string memory errorMessage
 133 |     |     ) internal returns (bytes memory) {
 134 |     |         require(address(this).balance >= value, "Address: insufficient balance for call");
 135 |     |         (bool success, bytes memory returndata) = target.call{value: value}(data);
 136 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 137 |     |     }
 138 |     | 
 139 |     |     /**
 140 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 141 |     |      * but performing a static call.
 142 |     |      *
 143 |     |      * _Available since v3.3._
 144 |     |      */
 145 |     |     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
 146 |     |         return functionStaticCall(target, data, "Address: low-level static call failed");
 147 |     |     }
 148 |     | 
 149 |     |     /**
 150 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
 151 |     |      * but performing a static call.
 152 |     |      *
 153 |     |      * _Available since v3.3._
 154 |     |      */
 155 |     |     function functionStaticCall(
 156 |     |         address target,
 157 |     |         bytes memory data,
 158 |     |         string memory errorMessage
 159 |     |     ) internal view returns (bytes memory) {
 160 |     |         (bool success, bytes memory returndata) = target.staticcall(data);
 161 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 162 |     |     }
 163 |     | 
 164 |     |     /**
 165 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 166 |     |      * but performing a delegate call.
 167 |     |      *
 168 |     |      * _Available since v3.4._
 169 |     |      */
 170 |     |     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
 171 |     |         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
 172 |     |     }
 173 |     | 
 174 |     |     /**
 175 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
 176 |     |      * but performing a delegate call.
 177 |     |      *
 178 |     |      * _Available since v3.4._
 179 |     |      */
 180 |     |     function functionDelegateCall(
 181 |     |         address target,
 182 |     |         bytes memory data,
 183 |     |         string memory errorMessage
 184 |     |     ) internal returns (bytes memory) {
 185 |     |         (bool success, bytes memory returndata) = target.delegatecall(data);
 186 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 187 |     |     }
 188 |     | 
 189 |     |     /**
 190 |     |      * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
 191 |     |      * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
 192 |     |      *
 193 |     |      * _Available since v4.8._
 194 |     |      */
 195 |     |     function verifyCallResultFromTarget(
 196 |     |         address target,
 197 |     |         bool success,
 198 |     |         bytes memory returndata,
 199 |     |         string memory errorMessage
 200 |     |     ) internal view returns (bytes memory) {
 201 |     |         if (success) {
 202 |     |             if (returndata.length == 0) {
 203 |     |                 // only check isContract if the call was successful and the return data is empty
 204 |     |                 // otherwise we already know that it was a contract
 205 |     |                 require(isContract(target), "Address: call to non-contract");
 206 |     |             }
 207 |     |             return returndata;
 208 |     |         } else {
 209 |     |             _revert(returndata, errorMessage);
 210 |     |         }
 211 |     |     }
 212 |     | 
 213 |     |     /**
 214 |     |      * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
 215 |     |      * revert reason or using the provided one.
 216 |     |      *
 217 |     |      * _Available since v4.3._
 218 |     |      */
 219 |     |     function verifyCallResult(
 220 |     |         bool success,
 221 |     |         bytes memory returndata,
 222 |     |         string memory errorMessage
 223 |     |     ) internal pure returns (bytes memory) {
 224 |     |         if (success) {
 225 |     |             return returndata;
 226 |     |         } else {
 227 |     |             _revert(returndata, errorMessage);
 228 |     |         }
 229 |     |     }
 230 |     | 
 231 |     |     function _revert(bytes memory returndata, string memory errorMessage) private pure {
 232 |     |         // Look for revert reason and bubble it up if present
 233 |     |         if (returndata.length > 0) {
 234 |     |             // The easiest way to bubble the revert reason is using memory via assembly
 235 |     |             /// @solidity memory-safe-assembly
 236 |     |             assembly {
 237 |     |                 let returndata_size := mload(returndata)
 238 |     |                 revert(add(32, returndata), returndata_size)
 239 |     |             }
 240 |     |         } else {
 241 |     |             revert(errorMessage);
 242 |     |         }
 243 |     |     }
 244 |     | }
 245 |     | 

/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 | *   |     function _msgSender() internal view virtual returns (address) {
 18 | *   |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | }
 25 |     | 

/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/utils/Strings.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "./math/Math.sol";
  7 |     | import "./math/SignedMath.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev String operations.
 11 |     |  */
 12 |     | library Strings {
 13 |     |     bytes16 private constant _SYMBOLS = "0123456789abcdef";
 14 |     |     uint8 private constant _ADDRESS_LENGTH = 20;
 15 |     | 
 16 |     |     /**
 17 |     |      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
 18 |     |      */
 19 |     |     function toString(uint256 value) internal pure returns (string memory) {
 20 |     |         unchecked {
 21 |     |             uint256 length = Math.log10(value) + 1;
 22 |     |             string memory buffer = new string(length);
 23 |     |             uint256 ptr;
 24 |     |             /// @solidity memory-safe-assembly
 25 |     |             assembly {
 26 |     |                 ptr := add(buffer, add(32, length))
 27 |     |             }
 28 |     |             while (true) {
 29 |     |                 ptr--;
 30 |     |                 /// @solidity memory-safe-assembly
 31 |     |                 assembly {
 32 |     |                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
 33 |     |                 }
 34 |     |                 value /= 10;
 35 |     |                 if (value == 0) break;
 36 |     |             }
 37 |     |             return buffer;
 38 |     |         }
 39 |     |     }
 40 |     | 
 41 |     |     /**
 42 |     |      * @dev Converts a `int256` to its ASCII `string` decimal representation.
 43 |     |      */
 44 |     |     function toString(int256 value) internal pure returns (string memory) {
 45 |     |         return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMath.abs(value))));
 46 |     |     }
 47 |     | 
 48 |     |     /**
 49 |     |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
 50 |     |      */
 51 |     |     function toHexString(uint256 value) internal pure returns (string memory) {
 52 |     |         unchecked {
 53 |     |             return toHexString(value, Math.log256(value) + 1);
 54 |     |         }
 55 |     |     }
 56 |     | 
 57 |     |     /**
 58 |     |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
 59 |     |      */
 60 |     |     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
 61 |     |         bytes memory buffer = new bytes(2 * length + 2);
 62 |     |         buffer[0] = "0";
 63 |     |         buffer[1] = "x";
 64 |     |         for (uint256 i = 2 * length + 1; i > 1; --i) {
 65 |     |             buffer[i] = _SYMBOLS[value & 0xf];
 66 |     |             value >>= 4;
 67 |     |         }
 68 |     |         require(value == 0, "Strings: hex length insufficient");
 69 |     |         return string(buffer);
 70 |     |     }
 71 |     | 
 72 |     |     /**
 73 |     |      * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.
 74 |     |      */
 75 |     |     function toHexString(address addr) internal pure returns (string memory) {
 76 |     |         return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);
 77 |     |     }
 78 |     | 
 79 |     |     /**
 80 |     |      * @dev Returns true if the two strings are equal.
 81 |     |      */
 82 |     |     function equal(string memory a, string memory b) internal pure returns (bool) {
 83 |     |         return keccak256(bytes(a)) == keccak256(bytes(b));
 84 |     |     }
 85 |     | }
 86 |     | 

/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "./IERC165.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Implementation of the {IERC165} interface.
 10 |     |  *
 11 |     |  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 12 |     |  * for the additional interface id that will be supported. For example:
 13 |     |  *
 14 |     |  * ```solidity
 15 |     |  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 16 |     |  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 17 |     |  * }
 18 |     |  * ```
 19 |     |  *
 20 |     |  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
 21 |     |  */
 22 |     | abstract contract ERC165 is IERC165 {
 23 |     |     /**
 24 |     |      * @dev See {IERC165-supportsInterface}.
 25 |     |      */
 26 | *   |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 27 | *   |         return interfaceId == type(IERC165).interfaceId;
 28 |     |     }
 29 |     | }
 30 |     | 

/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC165 standard, as defined in the
  8 |     |  * https://eips.ethereum.org/EIPS/eip-165[EIP].
  9 |     |  *
 10 |     |  * Implementers can declare support of contract interfaces, which can then be
 11 |     |  * queried by others ({ERC165Checker}).
 12 |     |  *
 13 |     |  * For an implementation, see {ERC165}.
 14 |     |  */
 15 |     | interface IERC165 {
 16 |     |     /**
 17 |     |      * @dev Returns true if this contract implements the interface defined by
 18 |     |      * `interfaceId`. See the corresponding
 19 |     |      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
 20 |     |      * to learn more about how these ids are created.
 21 |     |      *
 22 |     |      * This function call must use less than 30 000 gas.
 23 |     |      */
 24 |     |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
 25 |     | }
 26 |     | 

/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/utils/math/Math.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Standard math utilities missing in the Solidity language.
   8 |     |  */
   9 |     | library Math {
  10 |     |     enum Rounding {
  11 |     |         Down, // Toward negative infinity
  12 |     |         Up, // Toward infinity
  13 |     |         Zero // Toward zero
  14 |     |     }
  15 |     | 
  16 |     |     /**
  17 |     |      * @dev Returns the largest of two numbers.
  18 |     |      */
  19 |     |     function max(uint256 a, uint256 b) internal pure returns (uint256) {
  20 |     |         return a > b ? a : b;
  21 |     |     }
  22 |     | 
  23 |     |     /**
  24 |     |      * @dev Returns the smallest of two numbers.
  25 |     |      */
  26 |     |     function min(uint256 a, uint256 b) internal pure returns (uint256) {
  27 |     |         return a < b ? a : b;
  28 |     |     }
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Returns the average of two numbers. The result is rounded towards
  32 |     |      * zero.
  33 |     |      */
  34 |     |     function average(uint256 a, uint256 b) internal pure returns (uint256) {
  35 |     |         // (a + b) / 2 can overflow.
  36 |     |         return (a & b) + (a ^ b) / 2;
  37 |     |     }
  38 |     | 
  39 |     |     /**
  40 |     |      * @dev Returns the ceiling of the division of two numbers.
  41 |     |      *
  42 |     |      * This differs from standard division with `/` in that it rounds up instead
  43 |     |      * of rounding down.
  44 |     |      */
  45 |     |     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
  46 |     |         // (a + b - 1) / b can overflow on addition, so we distribute.
  47 |     |         return a == 0 ? 0 : (a - 1) / b + 1;
  48 |     |     }
  49 |     | 
  50 |     |     /**
  51 |     |      * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
  52 |     |      * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)
  53 |     |      * with further edits by Uniswap Labs also under MIT license.
  54 |     |      */
  55 |     |     function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {
  56 |     |         unchecked {
  57 |     |             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
  58 |     |             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
  59 |     |             // variables such that product = prod1 * 2^256 + prod0.
  60 |     |             uint256 prod0; // Least significant 256 bits of the product
  61 |     |             uint256 prod1; // Most significant 256 bits of the product
  62 |     |             assembly {
  63 |     |                 let mm := mulmod(x, y, not(0))
  64 |     |                 prod0 := mul(x, y)
  65 |     |                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
  66 |     |             }
  67 |     | 
  68 |     |             // Handle non-overflow cases, 256 by 256 division.
  69 |     |             if (prod1 == 0) {
  70 |     |                 return prod0 / denominator;
  71 |     |             }
  72 |     | 
  73 |     |             // Make sure the result is less than 2^256. Also prevents denominator == 0.
  74 |     |             require(denominator > prod1, "Math: mulDiv overflow");
  75 |     | 
  76 |     |             ///////////////////////////////////////////////
  77 |     |             // 512 by 256 division.
  78 |     |             ///////////////////////////////////////////////
  79 |     | 
  80 |     |             // Make division exact by subtracting the remainder from [prod1 prod0].
  81 |     |             uint256 remainder;
  82 |     |             assembly {
  83 |     |                 // Compute remainder using mulmod.
  84 |     |                 remainder := mulmod(x, y, denominator)
  85 |     | 
  86 |     |                 // Subtract 256 bit number from 512 bit number.
  87 |     |                 prod1 := sub(prod1, gt(remainder, prod0))
  88 |     |                 prod0 := sub(prod0, remainder)
  89 |     |             }
  90 |     | 
  91 |     |             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
  92 |     |             // See https://cs.stackexchange.com/q/138556/92363.
  93 |     | 
  94 |     |             // Does not overflow because the denominator cannot be zero at this stage in the function.
  95 |     |             uint256 twos = denominator & (~denominator + 1);
  96 |     |             assembly {
  97 |     |                 // Divide denominator by twos.
  98 |     |                 denominator := div(denominator, twos)
  99 |     | 
 100 |     |                 // Divide [prod1 prod0] by twos.
 101 |     |                 prod0 := div(prod0, twos)
 102 |     | 
 103 |     |                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
 104 |     |                 twos := add(div(sub(0, twos), twos), 1)
 105 |     |             }
 106 |     | 
 107 |     |             // Shift in bits from prod1 into prod0.
 108 |     |             prod0 |= prod1 * twos;
 109 |     | 
 110 |     |             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
 111 |     |             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
 112 |     |             // four bits. That is, denominator * inv = 1 mod 2^4.
 113 |     |             uint256 inverse = (3 * denominator) ^ 2;
 114 |     | 
 115 |     |             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
 116 |     |             // in modular arithmetic, doubling the correct bits in each step.
 117 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^8
 118 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^16
 119 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^32
 120 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^64
 121 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^128
 122 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^256
 123 |     | 
 124 |     |             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
 125 |     |             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
 126 |     |             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
 127 |     |             // is no longer required.
 128 |     |             result = prod0 * inverse;
 129 |     |             return result;
 130 |     |         }
 131 |     |     }
 132 |     | 
 133 |     |     /**
 134 |     |      * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.
 135 |     |      */
 136 |     |     function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {
 137 |     |         uint256 result = mulDiv(x, y, denominator);
 138 |     |         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
 139 |     |             result += 1;
 140 |     |         }
 141 |     |         return result;
 142 |     |     }
 143 |     | 
 144 |     |     /**
 145 |     |      * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.
 146 |     |      *
 147 |     |      * Inspired by Henry S. Warren, Jr.'s "Hacker's Delight" (Chapter 11).
 148 |     |      */
 149 |     |     function sqrt(uint256 a) internal pure returns (uint256) {
 150 |     |         if (a == 0) {
 151 |     |             return 0;
 152 |     |         }
 153 |     | 
 154 |     |         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
 155 |     |         //
 156 |     |         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
 157 |     |         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
 158 |     |         //
 159 |     |         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
 160 |     |         // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
 161 |     |         // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
 162 |     |         //
 163 |     |         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
 164 |     |         uint256 result = 1 << (log2(a) >> 1);
 165 |     | 
 166 |     |         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
 167 |     |         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
 168 |     |         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
 169 |     |         // into the expected uint128 result.
 170 |     |         unchecked {
 171 |     |             result = (result + a / result) >> 1;
 172 |     |             result = (result + a / result) >> 1;
 173 |     |             result = (result + a / result) >> 1;
 174 |     |             result = (result + a / result) >> 1;
 175 |     |             result = (result + a / result) >> 1;
 176 |     |             result = (result + a / result) >> 1;
 177 |     |             result = (result + a / result) >> 1;
 178 |     |             return min(result, a / result);
 179 |     |         }
 180 |     |     }
 181 |     | 
 182 |     |     /**
 183 |     |      * @notice Calculates sqrt(a), following the selected rounding direction.
 184 |     |      */
 185 |     |     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
 186 |     |         unchecked {
 187 |     |             uint256 result = sqrt(a);
 188 |     |             return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
 189 |     |         }
 190 |     |     }
 191 |     | 
 192 |     |     /**
 193 |     |      * @dev Return the log in base 2, rounded down, of a positive value.
 194 |     |      * Returns 0 if given 0.
 195 |     |      */
 196 |     |     function log2(uint256 value) internal pure returns (uint256) {
 197 |     |         uint256 result = 0;
 198 |     |         unchecked {
 199 |     |             if (value >> 128 > 0) {
 200 |     |                 value >>= 128;
 201 |     |                 result += 128;
 202 |     |             }
 203 |     |             if (value >> 64 > 0) {
 204 |     |                 value >>= 64;
 205 |     |                 result += 64;
 206 |     |             }
 207 |     |             if (value >> 32 > 0) {
 208 |     |                 value >>= 32;
 209 |     |                 result += 32;
 210 |     |             }
 211 |     |             if (value >> 16 > 0) {
 212 |     |                 value >>= 16;
 213 |     |                 result += 16;
 214 |     |             }
 215 |     |             if (value >> 8 > 0) {
 216 |     |                 value >>= 8;
 217 |     |                 result += 8;
 218 |     |             }
 219 |     |             if (value >> 4 > 0) {
 220 |     |                 value >>= 4;
 221 |     |                 result += 4;
 222 |     |             }
 223 |     |             if (value >> 2 > 0) {
 224 |     |                 value >>= 2;
 225 |     |                 result += 2;
 226 |     |             }
 227 |     |             if (value >> 1 > 0) {
 228 |     |                 result += 1;
 229 |     |             }
 230 |     |         }
 231 |     |         return result;
 232 |     |     }
 233 |     | 
 234 |     |     /**
 235 |     |      * @dev Return the log in base 2, following the selected rounding direction, of a positive value.
 236 |     |      * Returns 0 if given 0.
 237 |     |      */
 238 |     |     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
 239 |     |         unchecked {
 240 |     |             uint256 result = log2(value);
 241 |     |             return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
 242 |     |         }
 243 |     |     }
 244 |     | 
 245 |     |     /**
 246 |     |      * @dev Return the log in base 10, rounded down, of a positive value.
 247 |     |      * Returns 0 if given 0.
 248 |     |      */
 249 |     |     function log10(uint256 value) internal pure returns (uint256) {
 250 |     |         uint256 result = 0;
 251 |     |         unchecked {
 252 |     |             if (value >= 10 ** 64) {
 253 |     |                 value /= 10 ** 64;
 254 |     |                 result += 64;
 255 |     |             }
 256 |     |             if (value >= 10 ** 32) {
 257 |     |                 value /= 10 ** 32;
 258 |     |                 result += 32;
 259 |     |             }
 260 |     |             if (value >= 10 ** 16) {
 261 |     |                 value /= 10 ** 16;
 262 |     |                 result += 16;
 263 |     |             }
 264 |     |             if (value >= 10 ** 8) {
 265 |     |                 value /= 10 ** 8;
 266 |     |                 result += 8;
 267 |     |             }
 268 |     |             if (value >= 10 ** 4) {
 269 |     |                 value /= 10 ** 4;
 270 |     |                 result += 4;
 271 |     |             }
 272 |     |             if (value >= 10 ** 2) {
 273 |     |                 value /= 10 ** 2;
 274 |     |                 result += 2;
 275 |     |             }
 276 |     |             if (value >= 10 ** 1) {
 277 |     |                 result += 1;
 278 |     |             }
 279 |     |         }
 280 |     |         return result;
 281 |     |     }
 282 |     | 
 283 |     |     /**
 284 |     |      * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
 285 |     |      * Returns 0 if given 0.
 286 |     |      */
 287 |     |     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
 288 |     |         unchecked {
 289 |     |             uint256 result = log10(value);
 290 |     |             return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);
 291 |     |         }
 292 |     |     }
 293 |     | 
 294 |     |     /**
 295 |     |      * @dev Return the log in base 256, rounded down, of a positive value.
 296 |     |      * Returns 0 if given 0.
 297 |     |      *
 298 |     |      * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.
 299 |     |      */
 300 |     |     function log256(uint256 value) internal pure returns (uint256) {
 301 |     |         uint256 result = 0;
 302 |     |         unchecked {
 303 |     |             if (value >> 128 > 0) {
 304 |     |                 value >>= 128;
 305 |     |                 result += 16;
 306 |     |             }
 307 |     |             if (value >> 64 > 0) {
 308 |     |                 value >>= 64;
 309 |     |                 result += 8;
 310 |     |             }
 311 |     |             if (value >> 32 > 0) {
 312 |     |                 value >>= 32;
 313 |     |                 result += 4;
 314 |     |             }
 315 |     |             if (value >> 16 > 0) {
 316 |     |                 value >>= 16;
 317 |     |                 result += 2;
 318 |     |             }
 319 |     |             if (value >> 8 > 0) {
 320 |     |                 result += 1;
 321 |     |             }
 322 |     |         }
 323 |     |         return result;
 324 |     |     }
 325 |     | 
 326 |     |     /**
 327 |     |      * @dev Return the log in base 256, following the selected rounding direction, of a positive value.
 328 |     |      * Returns 0 if given 0.
 329 |     |      */
 330 |     |     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
 331 |     |         unchecked {
 332 |     |             uint256 result = log256(value);
 333 |     |             return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);
 334 |     |         }
 335 |     |     }
 336 |     | }
 337 |     | 

/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Standard signed math utilities missing in the Solidity language.
  8 |     |  */
  9 |     | library SignedMath {
 10 |     |     /**
 11 |     |      * @dev Returns the largest of two signed numbers.
 12 |     |      */
 13 |     |     function max(int256 a, int256 b) internal pure returns (int256) {
 14 |     |         return a > b ? a : b;
 15 |     |     }
 16 |     | 
 17 |     |     /**
 18 |     |      * @dev Returns the smallest of two signed numbers.
 19 |     |      */
 20 |     |     function min(int256 a, int256 b) internal pure returns (int256) {
 21 |     |         return a < b ? a : b;
 22 |     |     }
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the average of two signed numbers without overflow.
 26 |     |      * The result is rounded towards zero.
 27 |     |      */
 28 |     |     function average(int256 a, int256 b) internal pure returns (int256) {
 29 |     |         // Formula from the book "Hacker's Delight"
 30 |     |         int256 x = (a & b) + ((a ^ b) >> 1);
 31 |     |         return x + (int256(uint256(x) >> 255) & (a ^ b));
 32 |     |     }
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Returns the absolute unsigned value of a signed value.
 36 |     |      */
 37 |     |     function abs(int256 n) internal pure returns (uint256) {
 38 |     |         unchecked {
 39 |     |             // must be unchecked in order to support `n = type(int256).min`
 40 |     |             return uint256(n >= 0 ? n : -n);
 41 |     |         }
 42 |     |     }
 43 |     | }
 44 |     | 

/home/ivruix/Desktop/hw4/src/MyTokenModified.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
  5 |     | import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol";
  6 |     | import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
  7 |     | import "@openzeppelin/contracts/access/Ownable.sol";
  8 |     | 
  9 |     | contract MyTokenModified is ERC721, ERC721Enumerable, ERC721Burnable, Ownable {
 10 | *   |     uint256 public counter;
 11 |     | 
 12 |     |     constructor() ERC721("MyTokenModified", "MTKM") {}
 13 |     | 
 14 | *   |     function mint(address to, uint256 amount) public {
 15 | *   |         for (uint256 i; i < amount; i++) {
 16 | *o  |             _mint(to, counter++);
 17 |     |         }
 18 |     |     }
 19 |     | 
 20 | *o  |     function _beforeTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize)
 21 |     |         internal
 22 |     |         virtual
 23 |     |         override(ERC721, ERC721Enumerable)
 24 |     |     {
 25 | *   |         super._beforeTokenTransfer(from, to, tokenId, batchSize);
 26 |     |     }
 27 |     | 
 28 | *   |     function supportsInterface(bytes4 interfaceId)
 29 |     |         public
 30 |     |         view
 31 |     |         virtual
 32 |     |         override(ERC721, ERC721Enumerable)
 33 | *   |         returns (bool)
 34 |     |     {
 35 | *   |         return super.supportsInterface(interfaceId);
 36 |     |     }
 37 |     | 
 38 | *   |     function ownerOf(uint256 tokenId)
 39 |     |         public
 40 |     |         view
 41 |     |         virtual
 42 |     |         override(ERC721, IERC721)
 43 | *   |     returns (address) {
 44 | *   |         address owner = _ownerOf(tokenId);
 45 |     |         return owner;
 46 |     |     }
 47 |     | 
 48 | *   |     function balanceOf(address owner)
 49 |     |         public
 50 |     |         view
 51 |     |         virtual
 52 |     |         override(ERC721, IERC721)
 53 |     |     returns (uint256) {
 54 | *   |         return _balances[owner];
 55 |     |     }
 56 |     | 
 57 | *   |     function _transfer(address from, address to, uint256 tokenId)
 58 |     |         internal
 59 |     |         virtual
 60 |     |         override
 61 |     |     {
 62 | *   |         require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");
 63 | *   |         require(to != address(0), "ERC721: transfer to the zero address");
 64 |     | 
 65 | *   |         _beforeTokenTransfer(from, to, tokenId, 1);
 66 |     | 
 67 | *   |         require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");
 68 |     | 
 69 |     |         unchecked {
 70 | *   |             _balances[from] -= 1;
 71 | *   |             _balances[to] += 1;
 72 |     |         }
 73 | *   |         _owners[tokenId] = to;
 74 |     | 
 75 | *   |         emit Transfer(from, to, tokenId);
 76 |     | 
 77 |     |         _afterTokenTransfer(from, to, tokenId, 1);
 78 |     |     }
 79 |     | }
 80 |     | 

/home/ivruix/Desktop/hw4/test/CryticTestInternalModified.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "@crytic/properties/ERC721/internal/properties/ERC721BasicProperties.sol";
  5 |     | import "@crytic/properties/ERC721/internal/properties/ERC721BurnableProperties.sol";
  6 |     | import "@crytic/properties/ERC721/internal/properties/ERC721MintableProperties.sol";
  7 |     | import "../src/MyTokenModified.sol";
  8 |     | 
  9 | *r  | contract CryticERC721InternalHarness is
 10 |     |     MyTokenModified,
 11 |     |     CryticERC721BasicProperties,
 12 |     |     CryticERC721BurnableProperties,
 13 |     |     CryticERC721MintableProperties
 14 |     | {
 15 |     |     using Address for address;
 16 |     | 
 17 | *   |     constructor() {
 18 | *   |         isMintableOrBurnable = true;
 19 | *   |         safeReceiver = new MockReceiver(true);
 20 | *   |         unsafeReceiver = new MockReceiver(false);
 21 |     |     }
 22 |     | 
 23 | *   |     function _customMint(address to, uint256 amount) internal virtual override {
 24 | *   |         mint(to, amount);
 25 |     |     }
 26 |     | 
 27 | *   |     function _beforeTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize)
 28 |     |         internal
 29 |     |         virtual
 30 |     |         override(MyTokenModified, CryticERC721TestBase, CryticERC721BurnableProperties)
 31 |     |     {
 32 | *   |         super._beforeTokenTransfer(from, to, tokenId, batchSize);
 33 |     |     }
 34 |     | 
 35 | *   |     function supportsInterface(bytes4 interfaceId)
 36 |     |         public
 37 |     |         view
 38 |     |         virtual
 39 |     |         override(MyTokenModified, CryticERC721TestBase, CryticERC721BurnableProperties)
 40 | *   |         returns (bool)
 41 |     |     {
 42 | *   |         return super.supportsInterface(interfaceId);
 43 |     |     }
 44 |     | 
 45 | *   |     function ownerOf(uint256 tokenId)
 46 |     |         public
 47 |     |         view
 48 |     |         virtual
 49 |     |         override(MyTokenModified, ERC721, IERC721)
 50 | *   |         returns (address)
 51 |     |     {
 52 | *   |         return super.ownerOf(tokenId);
 53 |     |     }
 54 |     | 
 55 | *   |     function balanceOf(address owner)
 56 |     |         public
 57 |     |         view
 58 |     |         virtual
 59 | *   |         override(MyTokenModified, ERC721, IERC721) returns (uint256)
 60 |     |     {
 61 | *   |         return super.balanceOf(owner);
 62 |     |     }
 63 |     | 
 64 | *   |     function _transfer(address from, address to, uint256 tokenId)
 65 |     |         internal
 66 |     |         virtual
 67 |     |         override(MyTokenModified, ERC721)
 68 |     |     {
 69 | *   |         super._transfer(from, to, tokenId);
 70 |     |     }
 71 |     | }
 72 |     | 

