<style> code { white-space: pre-wrap; display: block; background-color: #eee; }.executed { background-color: #afa; }.reverted { background-color: #ffa; }.unexecuted { background-color: #faa; }.neutral { background-color: #eee; }</style><b>/home/ivruix/Desktop/hw4/lib/properties/contracts/ERC721/external/properties/ERC721ExternalBasicProperties.sol</b>
<code>
   1 |     | <span class='unexecuted'>pragma solidity ^0.8.13;</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>import &quot;../util/ERC721ExternalTestBase.sol&quot;;</span>
   4 |     | <span class='neutral'>import &quot;../../../util/Hevm.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>abstract contract CryticERC721ExternalBasicProperties is CryticERC721ExternalTestBase {</span>
   7 |     | <span class='neutral'>    using Address for address;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>    ////////////////////////////////////////</span>
  10 |     | <span class='neutral'>    // Properties</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    // Querying the balance of address(0) should throw</span>
  13 | *   | <span class='executed'>    function test_ERC721_external_balanceOfZeroAddressMustRevert() public virtual {</span>
  14 | *   | <span class='executed'>        token.balanceOf(address(0));</span>
  15 | *   | <span class='executed'>        assertWithMsg(false, &quot;address(0) balance query should have reverted&quot;);</span>
  16 |     | <span class='neutral'>    }</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    // Querying the owner of an invalid token should throw</span>
  19 | *   | <span class='executed'>    function test_ERC721_external_ownerOfInvalidTokenMustRevert() public virtual {</span>
  20 | *   | <span class='executed'>        token.ownerOf(type(uint256).max);</span>
  21 | *   | <span class='executed'>        assertWithMsg(false, &quot;Invalid token owner query should have reverted&quot;);</span>
  22 |     | <span class='neutral'>    }</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    // Approving an invalid token should throw</span>
  25 | *   | <span class='executed'>    function test_ERC721_external_approvingInvalidTokenMustRevert() public virtual {</span>
  26 | *r  | <span class='executed'>        token.approve(address(0), type(uint256).max);</span>
  27 |     | <span class='unexecuted'>        assertWithMsg(false, &quot;Approving an invalid token should have reverted&quot;);</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    // transferFrom a token that the caller is not approved for should revert</span>
  31 | *   | <span class='executed'>    function test_ERC721_external_transferFromNotApproved(address target) public virtual {</span>
  32 | *   | <span class='executed'>        uint256 selfBalance = token.balanceOf(msg.sender);</span>
  33 | *r  | <span class='executed'>        require(selfBalance &gt; 0);        </span>
  34 |     | <span class='unexecuted'>        require(target != address(this));</span>
  35 |     | <span class='unexecuted'>        require(target != msg.sender);</span>
  36 |     | <span class='unexecuted'>        uint tokenId = token.tokenOfOwnerByIndex(msg.sender, 0);</span>
  37 |     | <span class='unexecuted'>        bool isApproved = token.isApprovedForAll(msg.sender, address(this));</span>
  38 |     | <span class='unexecuted'>        address approved = token.getApproved(tokenId);</span>
  39 |     | <span class='unexecuted'>        require(approved != address(this) &amp;&amp; !isApproved);</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='unexecuted'>        token.transferFrom(msg.sender, target, tokenId);</span>
  42 |     | <span class='unexecuted'>        assertWithMsg(false, &quot;transferFrom without approval did not revert&quot;);</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    // transferFrom should reset approval for that token</span>
  46 | *   | <span class='executed'>    function test_ERC721_external_transferFromResetApproval(address target) public virtual {</span>
  47 | *   | <span class='executed'>        uint256 selfBalance = token.balanceOf(msg.sender);</span>
  48 | *r  | <span class='executed'>        require(selfBalance &gt; 0);  </span>
  49 |     | <span class='unexecuted'>        require(target != address(this));</span>
  50 |     | <span class='unexecuted'>        require(target != msg.sender);</span>
  51 |     | <span class='unexecuted'>        require(target != address(0));</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='unexecuted'>        uint tokenId = token.tokenOfOwnerByIndex(msg.sender, 0);</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='unexecuted'>        hevm.prank(msg.sender);</span>
  56 |     | <span class='unexecuted'>        token.approve(address(this), tokenId);</span>
  57 |     | <span class='unexecuted'>        token.transferFrom(msg.sender, target, tokenId);</span>
  58 |     | <span class='neutral'>        </span>
  59 |     | <span class='unexecuted'>        address approved = token.getApproved(tokenId);</span>
  60 |     | <span class='unexecuted'>        assertWithMsg(approved == address(0), &quot;Approval was not reset&quot;);</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    // transferFrom correctly updates owner</span>
  64 | *   | <span class='executed'>    function test_ERC721_external_transferFromUpdatesOwner(address target) public virtual {</span>
  65 | *   | <span class='executed'>        uint256 selfBalance = token.balanceOf(msg.sender);</span>
  66 | *r  | <span class='executed'>        require(selfBalance &gt; 0);  </span>
  67 |     | <span class='unexecuted'>        require(target != address(this));</span>
  68 |     | <span class='unexecuted'>        require(target != msg.sender);</span>
  69 |     | <span class='unexecuted'>        require(target != address(0));</span>
  70 |     | <span class='unexecuted'>        uint tokenId = token.tokenOfOwnerByIndex(msg.sender, 0);</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='unexecuted'>        hevm.prank(msg.sender);</span>
  73 |     | <span class='unexecuted'>        try token.transferFrom(msg.sender, target, tokenId) {</span>
  74 |     | <span class='unexecuted'>            assertWithMsg(token.ownerOf(tokenId) == target, &quot;Token owner not updated&quot;);</span>
  75 |     | <span class='neutral'>        } catch {</span>
  76 |     | <span class='unexecuted'>            assertWithMsg(false, &quot;transferFrom unexpectedly reverted&quot;);</span>
  77 |     | <span class='neutral'>        }</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    // transfer from zero address should revert</span>
  81 | *   | <span class='executed'>    function test_ERC721_external_transferFromZeroAddress(address target, uint256 tokenId) public virtual {</span>
  82 | *r  | <span class='executed'>        token.transferFrom(address(0), target, tokenId);</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>        assertWithMsg(false, &quot;transferFrom does not revert when `from` is the zero-address&quot;);</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>    // Transfers to the zero address should revert</span>
  88 | *   | <span class='executed'>    function test_ERC721_external_transferToZeroAddress() public virtual {</span>
  89 | *   | <span class='executed'>        uint256 selfBalance = token.balanceOf(msg.sender);</span>
  90 | *r  | <span class='executed'>        require(selfBalance &gt; 0); </span>
  91 |     | <span class='unexecuted'>        uint tokenId = token.tokenOfOwnerByIndex(msg.sender, 0);</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>        hevm.prank(msg.sender);</span>
  94 |     | <span class='unexecuted'>        token.transferFrom(msg.sender, address(0), tokenId);</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='unexecuted'>        assertWithMsg(false, &quot;Transfer to zero address should have reverted&quot;);</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    // Transfers to self should not break accounting</span>
 100 | *   | <span class='executed'>    function test_ERC721_external_transferFromSelf() public virtual {</span>
 101 | *   | <span class='executed'>        uint256 selfBalance = token.balanceOf(msg.sender);</span>
 102 | *r  | <span class='executed'>        require(selfBalance &gt; 0); </span>
 103 |     | <span class='unexecuted'>        uint tokenId = token.tokenOfOwnerByIndex(msg.sender, 0);</span>
 104 |     | <span class='unexecuted'>        hevm.prank(msg.sender);</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='unexecuted'>        try token.transferFrom(msg.sender, msg.sender, tokenId) {</span>
 107 |     | <span class='unexecuted'>            assertWithMsg(token.ownerOf(tokenId) == msg.sender, &quot;Self transfer changes owner&quot;);</span>
 108 |     | <span class='unexecuted'>            assertEq(token.balanceOf(msg.sender), selfBalance, &quot;Self transfer breaks accounting&quot;);</span>
 109 |     | <span class='neutral'>        } catch {</span>
 110 |     | <span class='unexecuted'>            assertWithMsg(false, &quot;transferFrom unexpectedly reverted&quot;);</span>
 111 |     | <span class='neutral'>        }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>    // Transfer to self reset approval</span>
 116 | *   | <span class='executed'>    function test_ERC721_external_transferFromSelfResetsApproval() public virtual {</span>
 117 | *   | <span class='executed'>        uint256 selfBalance = token.balanceOf(msg.sender);</span>
 118 | *r  | <span class='executed'>        require(selfBalance &gt; 0); </span>
 119 |     | <span class='unexecuted'>        uint tokenId = token.tokenOfOwnerByIndex(msg.sender, 0);</span>
 120 |     | <span class='unexecuted'>        require(token.ownerOf(tokenId) == msg.sender);</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='unexecuted'>        hevm.prank(msg.sender);</span>
 123 |     | <span class='unexecuted'>        token.approve(address(this), tokenId);</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='unexecuted'>        token.transferFrom(msg.sender, msg.sender, tokenId);</span>
 126 |     | <span class='unexecuted'>        assertWithMsg(token.getApproved(tokenId) == address(0), &quot;Self transfer does not reset approvals&quot;);</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    // safeTransferFrom reverts if receiver does not implement the callback</span>
 130 | *   | <span class='executed'>    function test_ERC721_external_safeTransferFromRevertsOnNoncontractReceiver() public virtual {</span>
 131 | *   | <span class='executed'>        uint256 selfBalance = token.balanceOf(msg.sender);</span>
 132 | *r  | <span class='executed'>        require(selfBalance &gt; 0); </span>
 133 |     | <span class='unexecuted'>        uint tokenId = token.tokenOfOwnerByIndex(msg.sender, 0);</span>
 134 |     | <span class='unexecuted'>        hevm.prank(msg.sender);</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='unexecuted'>        token.safeTransferFrom(msg.sender, address(mockUnsafeReceiver), tokenId);</span>
 137 |     | <span class='unexecuted'>        assertWithMsg(false, &quot;safeTransferFrom does not revert if receiver does not implement ERC721.onERC721Received&quot;);</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>}</span>
 141 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ivruix/Desktop/hw4/lib/properties/contracts/ERC721/external/properties/ERC721ExternalBurnableProperties.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>import &quot;../util/ERC721ExternalTestBase.sol&quot;;</span>
  4 |     | <span class='neutral'>import &quot;../../../util/Hevm.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>abstract contract CryticERC721ExternalBurnableProperties is CryticERC721ExternalTestBase {</span>
  7 |     | <span class='neutral'>    using Address for address;</span>
  8 |     | <span class='neutral'>    ////////////////////////////////////////</span>
  9 |     | <span class='neutral'>    // Properties</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    // The burn function should destroy tokens and reduce the total supply</span>
 12 | *   | <span class='executed'>    function test_ERC721_external_burnReducesTotalSupply() public virtual {</span>
 13 | *   | <span class='executed'>        require(token.isMintableOrBurnable());</span>
 14 | *   | <span class='executed'>        uint256 selfBalance = token.balanceOf(msg.sender);</span>
 15 | *r  | <span class='executed'>        require(selfBalance &gt; 0);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>        uint256 oldTotalSupply = token.totalSupply();</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>        for(uint256 i; i &lt; selfBalance; i++) {</span>
 20 |     | <span class='unexecuted'>            uint256 tokenId = token.tokenOfOwnerByIndex(msg.sender, 0);</span>
 21 |     | <span class='unexecuted'>            hevm.prank(msg.sender);</span>
 22 |     | <span class='unexecuted'>            token.burn(tokenId);</span>
 23 |     | <span class='neutral'>        }</span>
 24 |     | <span class='neutral'>        // Check for underflow</span>
 25 |     | <span class='unexecuted'>        assertWithMsg(selfBalance &lt;= oldTotalSupply, &quot;Underflow - user balance larger than total supply&quot;);</span>
 26 |     | <span class='unexecuted'>        assertEq(oldTotalSupply - selfBalance, token.totalSupply(), &quot;Incorrect supply update on burn&quot;);</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    // A burned token should not be transferrable</span>
 30 | *   | <span class='executed'>    function test_ERC721_external_burnRevertOnTransfer(address target) public virtual {</span>
 31 | *   | <span class='executed'>        require(token.isMintableOrBurnable());</span>
 32 | *   | <span class='executed'>        uint256 selfBalance = token.balanceOf(msg.sender);</span>
 33 | *r  | <span class='executed'>        require(selfBalance &gt; 0);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='unexecuted'>        uint256 tokenId = token.tokenOfOwnerByIndex(msg.sender, 0);</span>
 36 |     | <span class='unexecuted'>        hevm.prank(msg.sender);</span>
 37 |     | <span class='unexecuted'>        token.burn(tokenId);</span>
 38 |     | <span class='unexecuted'>        hevm.prank(msg.sender);</span>
 39 |     | <span class='unexecuted'>        token.transferFrom(msg.sender, target, tokenId);</span>
 40 |     | <span class='unexecuted'>        assertWithMsg(false, &quot;Transferring a burned token didn&#39;t revert&quot;);</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 | *   | <span class='executed'>    function test_ERC721_external_burnRevertOnApprove() public virtual {</span>
 44 | *   | <span class='executed'>        require(token.isMintableOrBurnable());</span>
 45 | *   | <span class='executed'>        uint256 selfBalance = token.balanceOf(msg.sender);</span>
 46 | *r  | <span class='executed'>        require(selfBalance &gt; 0);</span>
 47 |     | <span class='neutral'></span>
 48 | *   | <span class='executed'>        uint256 tokenId = token.tokenOfOwnerByIndex(msg.sender, 0);</span>
 49 | *   | <span class='executed'>        hevm.prank(msg.sender);</span>
 50 | *   | <span class='executed'>        token.burn(tokenId);</span>
 51 | *   | <span class='executed'>        hevm.prank(msg.sender);</span>
 52 | *r  | <span class='executed'>        token.approve(address(this), tokenId);</span>
 53 |     | <span class='unexecuted'>        assertWithMsg(false, &quot;Approving a burned token didn&#39;t revert&quot;);</span>
 54 |     | <span class='neutral'>    }</span>
 55 |     | <span class='neutral'></span>
 56 | *   | <span class='executed'>    function test_ERC721_external_burnRevertOnGetApproved() public virtual {</span>
 57 | *   | <span class='executed'>        require(token.isMintableOrBurnable());</span>
 58 | *   | <span class='executed'>        uint256 selfBalance = token.balanceOf(msg.sender);</span>
 59 | *r  | <span class='executed'>        require(selfBalance &gt; 0);</span>
 60 |     | <span class='neutral'></span>
 61 |     | <span class='unexecuted'>        uint256 tokenId = token.tokenOfOwnerByIndex(msg.sender, 0);</span>
 62 |     | <span class='unexecuted'>        hevm.prank(msg.sender);</span>
 63 |     | <span class='unexecuted'>        token.burn(tokenId);</span>
 64 |     | <span class='unexecuted'>        token.getApproved(tokenId);</span>
 65 |     | <span class='unexecuted'>        assertWithMsg(false, &quot;getApproved didn&#39;t revert for burned token&quot;);</span>
 66 |     | <span class='neutral'>    }</span>
 67 |     | <span class='neutral'></span>
 68 | *   | <span class='executed'>    function test_ERC721_external_burnRevertOnOwnerOf() public virtual {</span>
 69 | *   | <span class='executed'>        require(token.isMintableOrBurnable());</span>
 70 | *   | <span class='executed'>        uint256 selfBalance = token.balanceOf(msg.sender);</span>
 71 | *r  | <span class='executed'>        require(selfBalance &gt; 0);</span>
 72 |     | <span class='neutral'></span>
 73 |     | <span class='unexecuted'>        uint256 tokenId = token.tokenOfOwnerByIndex(msg.sender, 0);</span>
 74 |     | <span class='unexecuted'>        hevm.prank(msg.sender);</span>
 75 |     | <span class='unexecuted'>        token.burn(tokenId);</span>
 76 |     | <span class='unexecuted'>        token.ownerOf(tokenId);</span>
 77 |     | <span class='unexecuted'>        assertWithMsg(false, &quot;ownerOf didn&#39;t revert for burned token&quot;);</span>
 78 |     | <span class='neutral'>    }</span>
 79 |     | <span class='neutral'>}</span>
 80 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ivruix/Desktop/hw4/lib/properties/contracts/ERC721/external/properties/ERC721ExternalMintableProperties.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>import &quot;../util/ERC721ExternalTestBase.sol&quot;;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>abstract contract CryticERC721ExternalMintableProperties is CryticERC721ExternalTestBase {</span>
  6 |     | <span class='neutral'>    using Address for address;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>    ////////////////////////////////////////</span>
  9 |     | <span class='neutral'>    // Properties</span>
 10 |     | <span class='neutral'>    // mint increases the total supply.</span>
 11 |     | <span class='neutral'>    function test_ERC721_external_mintIncreasesSupply(uint256 amount) public virtual {</span>
 12 |     | <span class='neutral'>        require(token.isMintableOrBurnable());</span>
 13 |     | <span class='neutral'>        </span>
 14 |     | <span class='neutral'>        uint256 selfBalance = token.balanceOf(address(this));</span>
 15 |     | <span class='neutral'>        uint256 oldTotalSupply = token.totalSupply();</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>        try token._customMint(address(this), amount) {</span>
 18 |     | <span class='neutral'>            assertEq(oldTotalSupply + amount, token.totalSupply(), &quot;Total supply was not correctly increased&quot;);</span>
 19 |     | <span class='neutral'>            assertEq(selfBalance + amount, token.balanceOf(address(this)), &quot;Receiver supply was not correctly increased&quot;);</span>
 20 |     | <span class='neutral'>        } catch {</span>
 21 |     | <span class='neutral'>            assertWithMsg(false, &quot;Minting unexpectedly reverted&quot;);</span>
 22 |     | <span class='neutral'>        }</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    // mint creates a fresh token.</span>
 26 |     | <span class='neutral'>    function test_ERC721_external_mintCreatesFreshToken(uint256 amount) public virtual {</span>
 27 |     | <span class='neutral'>        require(token.isMintableOrBurnable());</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>        uint256 selfBalance = token.balanceOf(address(this));</span>
 30 |     | <span class='neutral'>        try token._customMint(address(this), amount) {</span>
 31 |     | <span class='neutral'>            uint256 tokenId = token.tokenOfOwnerByIndex(address(this), selfBalance);</span>
 32 |     | <span class='neutral'>            assertWithMsg(token.ownerOf(tokenId) == address(this), &quot;Token ID was not minted to receiver&quot;);</span>
 33 |     | <span class='neutral'>            assertWithMsg(!token.usedId(tokenId), &quot;Token ID minted is not new&quot;);</span>
 34 |     | <span class='neutral'>            assertEq(selfBalance + amount, token.balanceOf(address(this)), &quot;Receiver supply was not correctly increased&quot;);</span>
 35 |     | <span class='neutral'>        } catch {</span>
 36 |     | <span class='neutral'>            assertWithMsg(false, &quot;Minting unexpectedly reverted&quot;);</span>
 37 |     | <span class='neutral'>        }</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'>}</span>
 40 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ivruix/Desktop/hw4/lib/properties/contracts/ERC721/external/util/ERC721ExternalTestBase.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>import &quot;../../../util/PropertiesHelper.sol&quot;;</span>
  4 |     | <span class='neutral'>import &quot;../../util/IERC721Internal.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;../../../util/PropertiesConstants.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/utils/Address.sol&quot;;</span>
  7 |     | <span class='neutral'>import {MockReceiver} from &quot;./MockReceiver.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>abstract contract CryticERC721ExternalTestBase is PropertiesAsserts, PropertiesConstants {</span>
 11 |     | <span class='neutral'></span>
 12 | *   | <span class='executed'>    IERC721Internal public token;</span>
 13 | *   | <span class='executed'>    MockReceiver public mockSafeReceiver;</span>
 14 | *   | <span class='executed'>    MockReceiver public mockUnsafeReceiver;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    constructor() {</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>}</span>
 20 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ivruix/Desktop/hw4/lib/properties/contracts/ERC721/external/util/MockReceiver.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol&quot;;</span>
  4 |     | <span class='neutral'></span>
  5 | *r  | <span class='executed'>contract MockReceiver is ERC721Holder {</span>
  6 |     | <span class='neutral'>    bool shouldReceive;</span>
  7 |     | <span class='neutral'></span>
  8 | *   | <span class='executed'>    constructor(bool _shouldReceive) {</span>
  9 | *   | <span class='executed'>        shouldReceive = _shouldReceive;</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'></span>
 12 | *   | <span class='executed'>    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {</span>
 13 | *   | <span class='executed'>        if (shouldReceive) {</span>
 14 | *   | <span class='executed'>            return this.onERC721Received.selector;</span>
 15 |     | <span class='neutral'>        }</span>
 16 |     | <span class='neutral'></span>
 17 | *   | <span class='executed'>        return bytes4(0);</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ivruix/Desktop/hw4/lib/properties/contracts/ERC721/util/IERC721Internal.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC721/IERC721.sol&quot;;</span>
  4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IERC721Internal is IERC721, IERC721Enumerable {</span>
  7 |     | <span class='neutral'>    function isMintableOrBurnable() external returns (bool);</span>
  8 |     | <span class='neutral'>    function burn(uint256 tokenId) external;</span>
  9 |     | <span class='neutral'>    function usedId(uint256 tokenId) external view returns (bool);</span>
 10 |     | <span class='neutral'>    function _customMint(address to, uint256 amount) external;</span>
 11 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ivruix/Desktop/hw4/lib/properties/contracts/util/Hevm.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: Unlicense</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IHevm {</span>
  5 |     | <span class='neutral'>    // Set block.timestamp to newTimestamp</span>
  6 |     | <span class='neutral'>    function warp(uint256 newTimestamp) external;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>    // Set block.number to newNumber</span>
  9 |     | <span class='neutral'>    function roll(uint256 newNumber) external;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    // Add the condition b to the assumption base for the current branch</span>
 12 |     | <span class='neutral'>    // This function is almost identical to require</span>
 13 |     | <span class='neutral'>    function assume(bool b) external;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    // Sets the eth balance of usr to amt</span>
 16 |     | <span class='neutral'>    function deal(address usr, uint256 amt) external;</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    // Loads a storage slot from an address</span>
 19 |     | <span class='neutral'>    function load(address where, bytes32 slot) external returns (bytes32);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    // Stores a value to an address&#39; storage slot</span>
 22 |     | <span class='neutral'>    function store(address where, bytes32 slot, bytes32 value) external;</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    // Signs data (privateKey, digest) =&gt; (v, r, s)</span>
 25 |     | <span class='neutral'>    function sign(</span>
 26 |     | <span class='neutral'>        uint256 privateKey,</span>
 27 |     | <span class='neutral'>        bytes32 digest</span>
 28 |     | <span class='neutral'>    ) external returns (uint8 v, bytes32 r, bytes32 s);</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    // Gets address for a given private key</span>
 31 |     | <span class='neutral'>    function addr(uint256 privateKey) external returns (address addr);</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    // Performs a foreign function call via terminal</span>
 34 |     | <span class='neutral'>    function ffi(</span>
 35 |     | <span class='neutral'>        string[] calldata inputs</span>
 36 |     | <span class='neutral'>    ) external returns (bytes memory result);</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='neutral'>    // Performs the next smart contract call with specified `msg.sender`</span>
 39 |     | <span class='neutral'>    function prank(address newSender) external;</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    // Creates a new fork with the given endpoint and the latest block and returns the identifier of the fork</span>
 42 |     | <span class='neutral'>    function createFork(string calldata urlOrAlias) external returns (uint256);</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    // Takes a fork identifier created by createFork and sets the corresponding forked state as active</span>
 45 |     | <span class='neutral'>    function selectFork(uint256 forkId) external;</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    // Returns the identifier of the current fork</span>
 48 |     | <span class='neutral'>    function activeFork() external returns (uint256);</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    // Labels the address in traces</span>
 51 |     | <span class='neutral'>    function label(address addr, string calldata label) external;</span>
 52 |     | <span class='neutral'>}</span>
 53 |     | <span class='neutral'></span>
 54 | *   | <span class='executed'>IHevm constant hevm = IHevm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);</span>
 55 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ivruix/Desktop/hw4/lib/properties/contracts/util/PropertiesConstants.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>abstract contract PropertiesConstants {</span>
  4 |     | <span class='neutral'>    // Constant echidna addresses</span>
  5 |     | <span class='neutral'>    address constant USER1 = address(0x10000);</span>
  6 |     | <span class='neutral'>    address constant USER2 = address(0x20000);</span>
  7 |     | <span class='neutral'>    address constant USER3 = address(0x30000);</span>
  8 |     | <span class='neutral'>    uint256 constant INITIAL_BALANCE = 1000e18;</span>
  9 |     | <span class='neutral'>}</span>
 10 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ivruix/Desktop/hw4/lib/properties/contracts/util/PropertiesHelper.sol</b>
<code>
   1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>abstract contract PropertiesAsserts {</span>
   4 |     | <span class='neutral'>    event LogUint256(string, uint256);</span>
   5 |     | <span class='neutral'>    event LogAddress(string, address);</span>
   6 |     | <span class='neutral'>    event LogString(string);</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>    event AssertFail(string);</span>
   9 |     | <span class='neutral'>    event AssertEqFail(string);</span>
  10 |     | <span class='neutral'>    event AssertNeqFail(string);</span>
  11 |     | <span class='neutral'>    event AssertGteFail(string);</span>
  12 |     | <span class='neutral'>    event AssertGtFail(string);</span>
  13 |     | <span class='neutral'>    event AssertLteFail(string);</span>
  14 |     | <span class='neutral'>    event AssertLtFail(string);</span>
  15 |     | <span class='neutral'></span>
  16 | *   | <span class='executed'>    function assertWithMsg(bool b, string memory reason) internal {</span>
  17 | *   | <span class='executed'>        if (!b) {</span>
  18 | *   | <span class='executed'>            emit AssertFail(reason);</span>
  19 | *   | <span class='executed'>            assert(false);</span>
  20 |     | <span class='neutral'>        }</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    /// @notice asserts that a is equal to b. Violations are logged using reason.</span>
  24 |     | <span class='unexecuted'>    function assertEq(uint256 a, uint256 b, string memory reason) internal {</span>
  25 |     | <span class='unexecuted'>        if (a != b) {</span>
  26 |     | <span class='unexecuted'>            string memory aStr = PropertiesLibString.toString(a);</span>
  27 |     | <span class='unexecuted'>            string memory bStr = PropertiesLibString.toString(b);</span>
  28 |     | <span class='unexecuted'>            bytes memory assertMsg = abi.encodePacked(</span>
  29 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
  30 |     | <span class='unexecuted'>                aStr,</span>
  31 |     | <span class='neutral'>                &quot;!=&quot;,</span>
  32 |     | <span class='unexecuted'>                bStr,</span>
  33 |     | <span class='neutral'>                &quot;, reason: &quot;,</span>
  34 |     | <span class='unexecuted'>                reason</span>
  35 |     | <span class='neutral'>            );</span>
  36 |     | <span class='unexecuted'>            emit AssertEqFail(string(assertMsg));</span>
  37 |     | <span class='unexecuted'>            assert(false);</span>
  38 |     | <span class='neutral'>        }</span>
  39 |     | <span class='neutral'>    }</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /// @notice int256 version of assertEq</span>
  42 |     | <span class='neutral'>    function assertEq(int256 a, int256 b, string memory reason) internal {</span>
  43 |     | <span class='neutral'>        if (a != b) {</span>
  44 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
  45 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
  46 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
  47 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
  48 |     | <span class='neutral'>                aStr,</span>
  49 |     | <span class='neutral'>                &quot;!=&quot;,</span>
  50 |     | <span class='neutral'>                bStr,</span>
  51 |     | <span class='neutral'>                &quot;, reason: &quot;,</span>
  52 |     | <span class='neutral'>                reason</span>
  53 |     | <span class='neutral'>            );</span>
  54 |     | <span class='neutral'>            emit AssertEqFail(string(assertMsg));</span>
  55 |     | <span class='neutral'>            assert(false);</span>
  56 |     | <span class='neutral'>        }</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /// @notice asserts that a is not equal to b. Violations are logged using reason.</span>
  60 |     | <span class='neutral'>    function assertNeq(uint256 a, uint256 b, string memory reason) internal {</span>
  61 |     | <span class='neutral'>        if (a == b) {</span>
  62 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
  63 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
  64 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
  65 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
  66 |     | <span class='neutral'>                aStr,</span>
  67 |     | <span class='neutral'>                &quot;==&quot;,</span>
  68 |     | <span class='neutral'>                bStr,</span>
  69 |     | <span class='neutral'>                &quot;, reason: &quot;,</span>
  70 |     | <span class='neutral'>                reason</span>
  71 |     | <span class='neutral'>            );</span>
  72 |     | <span class='neutral'>            emit AssertNeqFail(string(assertMsg));</span>
  73 |     | <span class='neutral'>            assert(false);</span>
  74 |     | <span class='neutral'>        }</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    /// @notice int256 version of assertNeq</span>
  78 |     | <span class='neutral'>    function assertNeq(int256 a, int256 b, string memory reason) internal {</span>
  79 |     | <span class='neutral'>        if (a == b) {</span>
  80 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
  81 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
  82 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
  83 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
  84 |     | <span class='neutral'>                aStr,</span>
  85 |     | <span class='neutral'>                &quot;==&quot;,</span>
  86 |     | <span class='neutral'>                bStr,</span>
  87 |     | <span class='neutral'>                &quot;, reason: &quot;,</span>
  88 |     | <span class='neutral'>                reason</span>
  89 |     | <span class='neutral'>            );</span>
  90 |     | <span class='neutral'>            emit AssertNeqFail(string(assertMsg));</span>
  91 |     | <span class='neutral'>            assert(false);</span>
  92 |     | <span class='neutral'>        }</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    /// @notice asserts that a is greater than or equal to b. Violations are logged using reason.</span>
  96 |     | <span class='neutral'>    function assertGte(uint256 a, uint256 b, string memory reason) internal {</span>
  97 |     | <span class='neutral'>        if (!(a &gt;= b)) {</span>
  98 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
  99 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
 100 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
 101 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 102 |     | <span class='neutral'>                aStr,</span>
 103 |     | <span class='neutral'>                &quot;&lt;&quot;,</span>
 104 |     | <span class='neutral'>                bStr,</span>
 105 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 106 |     | <span class='neutral'>                reason</span>
 107 |     | <span class='neutral'>            );</span>
 108 |     | <span class='neutral'>            emit AssertGteFail(string(assertMsg));</span>
 109 |     | <span class='neutral'>            assert(false);</span>
 110 |     | <span class='neutral'>        }</span>
 111 |     | <span class='neutral'>    }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>    /// @notice int256 version of assertGte</span>
 114 |     | <span class='neutral'>    function assertGte(int256 a, int256 b, string memory reason) internal {</span>
 115 |     | <span class='neutral'>        if (!(a &gt;= b)) {</span>
 116 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 117 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
 118 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
 119 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 120 |     | <span class='neutral'>                aStr,</span>
 121 |     | <span class='neutral'>                &quot;&lt;&quot;,</span>
 122 |     | <span class='neutral'>                bStr,</span>
 123 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 124 |     | <span class='neutral'>                reason</span>
 125 |     | <span class='neutral'>            );</span>
 126 |     | <span class='neutral'>            emit AssertGteFail(string(assertMsg));</span>
 127 |     | <span class='neutral'>            assert(false);</span>
 128 |     | <span class='neutral'>        }</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    /// @notice asserts that a is greater than b. Violations are logged using reason.</span>
 132 |     | <span class='neutral'>    function assertGt(uint256 a, uint256 b, string memory reason) internal {</span>
 133 |     | <span class='neutral'>        if (!(a &gt; b)) {</span>
 134 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 135 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
 136 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
 137 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 138 |     | <span class='neutral'>                aStr,</span>
 139 |     | <span class='neutral'>                &quot;&lt;=&quot;,</span>
 140 |     | <span class='neutral'>                bStr,</span>
 141 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 142 |     | <span class='neutral'>                reason</span>
 143 |     | <span class='neutral'>            );</span>
 144 |     | <span class='neutral'>            emit AssertGtFail(string(assertMsg));</span>
 145 |     | <span class='neutral'>            assert(false);</span>
 146 |     | <span class='neutral'>        }</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /// @notice int256 version of assertGt</span>
 150 |     | <span class='neutral'>    function assertGt(int256 a, int256 b, string memory reason) internal {</span>
 151 |     | <span class='neutral'>        if (!(a &gt; b)) {</span>
 152 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 153 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
 154 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
 155 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 156 |     | <span class='neutral'>                aStr,</span>
 157 |     | <span class='neutral'>                &quot;&lt;=&quot;,</span>
 158 |     | <span class='neutral'>                bStr,</span>
 159 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 160 |     | <span class='neutral'>                reason</span>
 161 |     | <span class='neutral'>            );</span>
 162 |     | <span class='neutral'>            emit AssertGtFail(string(assertMsg));</span>
 163 |     | <span class='neutral'>            assert(false);</span>
 164 |     | <span class='neutral'>        }</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    /// @notice asserts that a is less than or equal to b. Violations are logged using reason.</span>
 168 |     | <span class='neutral'>    function assertLte(uint256 a, uint256 b, string memory reason) internal {</span>
 169 |     | <span class='neutral'>        if (!(a &lt;= b)) {</span>
 170 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 171 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
 172 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
 173 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 174 |     | <span class='neutral'>                aStr,</span>
 175 |     | <span class='neutral'>                &quot;&gt;&quot;,</span>
 176 |     | <span class='neutral'>                bStr,</span>
 177 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 178 |     | <span class='neutral'>                reason</span>
 179 |     | <span class='neutral'>            );</span>
 180 |     | <span class='neutral'>            emit AssertLteFail(string(assertMsg));</span>
 181 |     | <span class='neutral'>            assert(false);</span>
 182 |     | <span class='neutral'>        }</span>
 183 |     | <span class='neutral'>    }</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>    /// @notice int256 version of assertLte</span>
 186 |     | <span class='neutral'>    function assertLte(int256 a, int256 b, string memory reason) internal {</span>
 187 |     | <span class='neutral'>        if (!(a &lt;= b)) {</span>
 188 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 189 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
 190 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
 191 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 192 |     | <span class='neutral'>                aStr,</span>
 193 |     | <span class='neutral'>                &quot;&gt;&quot;,</span>
 194 |     | <span class='neutral'>                bStr,</span>
 195 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 196 |     | <span class='neutral'>                reason</span>
 197 |     | <span class='neutral'>            );</span>
 198 |     | <span class='neutral'>            emit AssertLteFail(string(assertMsg));</span>
 199 |     | <span class='neutral'>            assert(false);</span>
 200 |     | <span class='neutral'>        }</span>
 201 |     | <span class='neutral'>    }</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>    /// @notice asserts that a is less than b. Violations are logged using reason.</span>
 204 |     | <span class='neutral'>    function assertLt(uint256 a, uint256 b, string memory reason) internal {</span>
 205 |     | <span class='neutral'>        if (!(a &lt; b)) {</span>
 206 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 207 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
 208 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
 209 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 210 |     | <span class='neutral'>                aStr,</span>
 211 |     | <span class='neutral'>                &quot;&gt;=&quot;,</span>
 212 |     | <span class='neutral'>                bStr,</span>
 213 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 214 |     | <span class='neutral'>                reason</span>
 215 |     | <span class='neutral'>            );</span>
 216 |     | <span class='neutral'>            emit AssertLtFail(string(assertMsg));</span>
 217 |     | <span class='neutral'>            assert(false);</span>
 218 |     | <span class='neutral'>        }</span>
 219 |     | <span class='neutral'>    }</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='neutral'>    /// @notice int256 version of assertLt</span>
 222 |     | <span class='neutral'>    function assertLt(int256 a, int256 b, string memory reason) internal {</span>
 223 |     | <span class='neutral'>        if (!(a &lt; b)) {</span>
 224 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 225 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
 226 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
 227 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 228 |     | <span class='neutral'>                aStr,</span>
 229 |     | <span class='neutral'>                &quot;&gt;=&quot;,</span>
 230 |     | <span class='neutral'>                bStr,</span>
 231 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 232 |     | <span class='neutral'>                reason</span>
 233 |     | <span class='neutral'>            );</span>
 234 |     | <span class='neutral'>            emit AssertLtFail(string(assertMsg));</span>
 235 |     | <span class='neutral'>            assert(false);</span>
 236 |     | <span class='neutral'>        }</span>
 237 |     | <span class='neutral'>    }</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='neutral'>    /// @notice Clamps value to be between low and high, both inclusive</span>
 240 |     | <span class='neutral'>    function clampBetween(</span>
 241 |     | <span class='neutral'>        uint256 value,</span>
 242 |     | <span class='neutral'>        uint256 low,</span>
 243 |     | <span class='neutral'>        uint256 high</span>
 244 |     | <span class='neutral'>    ) internal returns (uint256) {</span>
 245 |     | <span class='neutral'>        if (value &lt; low || value &gt; high) {</span>
 246 |     | <span class='neutral'>            uint ans = low + (value % (high - low + 1));</span>
 247 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 248 |     | <span class='neutral'>            string memory ansStr = PropertiesLibString.toString(ans);</span>
 249 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 250 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 251 |     | <span class='neutral'>                valueStr,</span>
 252 |     | <span class='neutral'>                &quot; to &quot;,</span>
 253 |     | <span class='neutral'>                ansStr</span>
 254 |     | <span class='neutral'>            );</span>
 255 |     | <span class='neutral'>            emit LogString(string(message));</span>
 256 |     | <span class='neutral'>            return ans;</span>
 257 |     | <span class='neutral'>        }</span>
 258 |     | <span class='neutral'>        return value;</span>
 259 |     | <span class='neutral'>    }</span>
 260 |     | <span class='neutral'></span>
 261 |     | <span class='neutral'>    /// @notice int256 version of clampBetween</span>
 262 |     | <span class='neutral'>    function clampBetween(</span>
 263 |     | <span class='neutral'>        int256 value,</span>
 264 |     | <span class='neutral'>        int256 low,</span>
 265 |     | <span class='neutral'>        int256 high</span>
 266 |     | <span class='neutral'>    ) internal returns (int256) {</span>
 267 |     | <span class='neutral'>        if (value &lt; low || value &gt; high) {</span>
 268 |     | <span class='neutral'>            int range = high - low + 1;</span>
 269 |     | <span class='neutral'>            int clamped = (value - low) % (range);</span>
 270 |     | <span class='neutral'>            if (clamped &lt; 0) clamped += range;</span>
 271 |     | <span class='neutral'>            int ans = low + clamped;</span>
 272 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 273 |     | <span class='neutral'>            string memory ansStr = PropertiesLibString.toString(ans);</span>
 274 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 275 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 276 |     | <span class='neutral'>                valueStr,</span>
 277 |     | <span class='neutral'>                &quot; to &quot;,</span>
 278 |     | <span class='neutral'>                ansStr</span>
 279 |     | <span class='neutral'>            );</span>
 280 |     | <span class='neutral'>            emit LogString(string(message));</span>
 281 |     | <span class='neutral'>            return ans;</span>
 282 |     | <span class='neutral'>        }</span>
 283 |     | <span class='neutral'>        return value;</span>
 284 |     | <span class='neutral'>    }</span>
 285 |     | <span class='neutral'></span>
 286 |     | <span class='neutral'>    /// @notice clamps a to be less than b</span>
 287 |     | <span class='neutral'>    function clampLt(uint256 a, uint256 b) internal returns (uint256) {</span>
 288 |     | <span class='neutral'>        if (!(a &lt; b)) {</span>
 289 |     | <span class='neutral'>            assertNeq(</span>
 290 |     | <span class='neutral'>                b,</span>
 291 |     | <span class='neutral'>                0,</span>
 292 |     | <span class='neutral'>                &quot;clampLt cannot clamp value a to be less than zero. Check your inputs/assumptions.&quot;</span>
 293 |     | <span class='neutral'>            );</span>
 294 |     | <span class='neutral'>            uint256 value = a % b;</span>
 295 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 296 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 297 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 298 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 299 |     | <span class='neutral'>                aStr,</span>
 300 |     | <span class='neutral'>                &quot; to &quot;,</span>
 301 |     | <span class='neutral'>                valueStr</span>
 302 |     | <span class='neutral'>            );</span>
 303 |     | <span class='neutral'>            emit LogString(string(message));</span>
 304 |     | <span class='neutral'>            return value;</span>
 305 |     | <span class='neutral'>        }</span>
 306 |     | <span class='neutral'>        return a;</span>
 307 |     | <span class='neutral'>    }</span>
 308 |     | <span class='neutral'></span>
 309 |     | <span class='neutral'>    /// @notice int256 version of clampLt</span>
 310 |     | <span class='neutral'>    function clampLt(int256 a, int256 b) internal returns (int256) {</span>
 311 |     | <span class='neutral'>        if (!(a &lt; b)) {</span>
 312 |     | <span class='neutral'>            int256 value = b - 1;</span>
 313 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 314 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 315 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 316 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 317 |     | <span class='neutral'>                aStr,</span>
 318 |     | <span class='neutral'>                &quot; to &quot;,</span>
 319 |     | <span class='neutral'>                valueStr</span>
 320 |     | <span class='neutral'>            );</span>
 321 |     | <span class='neutral'>            emit LogString(string(message));</span>
 322 |     | <span class='neutral'>            return value;</span>
 323 |     | <span class='neutral'>        }</span>
 324 |     | <span class='neutral'>        return a;</span>
 325 |     | <span class='neutral'>    }</span>
 326 |     | <span class='neutral'></span>
 327 |     | <span class='neutral'>    /// @notice clamps a to be less than or equal to b</span>
 328 |     | <span class='neutral'>    function clampLte(uint256 a, uint256 b) internal returns (uint256) {</span>
 329 |     | <span class='neutral'>        if (!(a &lt;= b)) {</span>
 330 |     | <span class='neutral'>            uint256 value = a % (b + 1);</span>
 331 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 332 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 333 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 334 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 335 |     | <span class='neutral'>                aStr,</span>
 336 |     | <span class='neutral'>                &quot; to &quot;,</span>
 337 |     | <span class='neutral'>                valueStr</span>
 338 |     | <span class='neutral'>            );</span>
 339 |     | <span class='neutral'>            emit LogString(string(message));</span>
 340 |     | <span class='neutral'>            return value;</span>
 341 |     | <span class='neutral'>        }</span>
 342 |     | <span class='neutral'>        return a;</span>
 343 |     | <span class='neutral'>    }</span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='neutral'>    /// @notice int256 version of clampLte</span>
 346 |     | <span class='neutral'>    function clampLte(int256 a, int256 b) internal returns (int256) {</span>
 347 |     | <span class='neutral'>        if (!(a &lt;= b)) {</span>
 348 |     | <span class='neutral'>            int256 value = b;</span>
 349 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 350 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 351 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 352 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 353 |     | <span class='neutral'>                aStr,</span>
 354 |     | <span class='neutral'>                &quot; to &quot;,</span>
 355 |     | <span class='neutral'>                valueStr</span>
 356 |     | <span class='neutral'>            );</span>
 357 |     | <span class='neutral'>            emit LogString(string(message));</span>
 358 |     | <span class='neutral'>            return value;</span>
 359 |     | <span class='neutral'>        }</span>
 360 |     | <span class='neutral'>        return a;</span>
 361 |     | <span class='neutral'>    }</span>
 362 |     | <span class='neutral'></span>
 363 |     | <span class='neutral'>    /// @notice clamps a to be greater than b</span>
 364 |     | <span class='neutral'>    function clampGt(uint256 a, uint256 b) internal returns (uint256) {</span>
 365 |     | <span class='neutral'>        if (!(a &gt; b)) {</span>
 366 |     | <span class='neutral'>            assertNeq(</span>
 367 |     | <span class='neutral'>                b,</span>
 368 |     | <span class='neutral'>                type(uint256).max,</span>
 369 |     | <span class='neutral'>                &quot;clampGt cannot clamp value a to be larger than uint256.max. Check your inputs/assumptions.&quot;</span>
 370 |     | <span class='neutral'>            );</span>
 371 |     | <span class='neutral'>            uint256 value = b + 1;</span>
 372 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 373 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 374 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 375 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 376 |     | <span class='neutral'>                aStr,</span>
 377 |     | <span class='neutral'>                &quot; to &quot;,</span>
 378 |     | <span class='neutral'>                valueStr</span>
 379 |     | <span class='neutral'>            );</span>
 380 |     | <span class='neutral'>            emit LogString(string(message));</span>
 381 |     | <span class='neutral'>            return value;</span>
 382 |     | <span class='neutral'>        } else {</span>
 383 |     | <span class='neutral'>            return a;</span>
 384 |     | <span class='neutral'>        }</span>
 385 |     | <span class='neutral'>    }</span>
 386 |     | <span class='neutral'></span>
 387 |     | <span class='neutral'>    /// @notice int256 version of clampGt</span>
 388 |     | <span class='neutral'>    function clampGt(int256 a, int256 b) internal returns (int256) {</span>
 389 |     | <span class='neutral'>        if (!(a &gt; b)) {</span>
 390 |     | <span class='neutral'>            int256 value = b + 1;</span>
 391 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 392 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 393 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 394 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 395 |     | <span class='neutral'>                aStr,</span>
 396 |     | <span class='neutral'>                &quot; to &quot;,</span>
 397 |     | <span class='neutral'>                valueStr</span>
 398 |     | <span class='neutral'>            );</span>
 399 |     | <span class='neutral'>            emit LogString(string(message));</span>
 400 |     | <span class='neutral'>            return value;</span>
 401 |     | <span class='neutral'>        } else {</span>
 402 |     | <span class='neutral'>            return a;</span>
 403 |     | <span class='neutral'>        }</span>
 404 |     | <span class='neutral'>    }</span>
 405 |     | <span class='neutral'></span>
 406 |     | <span class='neutral'>    /// @notice clamps a to be greater than or equal to b</span>
 407 |     | <span class='neutral'>    function clampGte(uint256 a, uint256 b) internal returns (uint256) {</span>
 408 |     | <span class='neutral'>        if (!(a &gt; b)) {</span>
 409 |     | <span class='neutral'>            uint256 value = b;</span>
 410 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 411 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 412 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 413 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 414 |     | <span class='neutral'>                aStr,</span>
 415 |     | <span class='neutral'>                &quot; to &quot;,</span>
 416 |     | <span class='neutral'>                valueStr</span>
 417 |     | <span class='neutral'>            );</span>
 418 |     | <span class='neutral'>            emit LogString(string(message));</span>
 419 |     | <span class='neutral'>            return value;</span>
 420 |     | <span class='neutral'>        }</span>
 421 |     | <span class='neutral'>        return a;</span>
 422 |     | <span class='neutral'>    }</span>
 423 |     | <span class='neutral'></span>
 424 |     | <span class='neutral'>    /// @notice int256 version of clampGte</span>
 425 |     | <span class='neutral'>    function clampGte(int256 a, int256 b) internal returns (int256) {</span>
 426 |     | <span class='neutral'>        if (!(a &gt; b)) {</span>
 427 |     | <span class='neutral'>            int256 value = b;</span>
 428 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 429 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 430 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 431 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 432 |     | <span class='neutral'>                aStr,</span>
 433 |     | <span class='neutral'>                &quot; to &quot;,</span>
 434 |     | <span class='neutral'>                valueStr</span>
 435 |     | <span class='neutral'>            );</span>
 436 |     | <span class='neutral'>            emit LogString(string(message));</span>
 437 |     | <span class='neutral'>            return value;</span>
 438 |     | <span class='neutral'>        }</span>
 439 |     | <span class='neutral'>        return a;</span>
 440 |     | <span class='neutral'>    }</span>
 441 |     | <span class='neutral'>}</span>
 442 |     | <span class='neutral'></span>
 443 |     | <span class='neutral'>/// @notice Efficient library for creating string representations of integers.</span>
 444 |     | <span class='neutral'>/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)</span>
 445 |     | <span class='neutral'>/// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibString.sol)</span>
 446 |     | <span class='neutral'>/// @dev Name of the library is modified to prevent collisions with contract-under-test uses of LibString</span>
 447 |     | <span class='unexecuted'>library PropertiesLibString {</span>
 448 |     | <span class='neutral'>    function toString(int256 value) internal pure returns (string memory str) {</span>
 449 |     | <span class='neutral'>        uint256 absValue = value &gt;= 0 ? uint256(value) : uint256(-value);</span>
 450 |     | <span class='neutral'>        str = toString(absValue);</span>
 451 |     | <span class='neutral'></span>
 452 |     | <span class='neutral'>        if (value &lt; 0) {</span>
 453 |     | <span class='neutral'>            str = string(abi.encodePacked(&quot;-&quot;, str));</span>
 454 |     | <span class='neutral'>        }</span>
 455 |     | <span class='neutral'>    }</span>
 456 |     | <span class='neutral'></span>
 457 |     | <span class='unexecuted'>    function toString(uint256 value) internal pure returns (string memory str) {</span>
 458 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 459 |     | <span class='neutral'>        assembly {</span>
 460 |     | <span class='neutral'>            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but we allocate 160 bytes</span>
 461 |     | <span class='neutral'>            // to keep the free memory pointer word aligned. We&#39;ll need 1 word for the length, 1 word for the</span>
 462 |     | <span class='neutral'>            // trailing zeros padding, and 3 other words for a max of 78 digits. In total: 5 * 32 = 160 bytes.</span>
 463 |     | <span class='unexecuted'>            let newFreeMemoryPointer := add(mload(0x40), 160)</span>
 464 |     | <span class='neutral'></span>
 465 |     | <span class='neutral'>            // Update the free memory pointer to avoid overriding our string.</span>
 466 |     | <span class='unexecuted'>            mstore(0x40, newFreeMemoryPointer)</span>
 467 |     | <span class='neutral'></span>
 468 |     | <span class='neutral'>            // Assign str to the end of the zone of newly allocated memory.</span>
 469 |     | <span class='unexecuted'>            str := sub(newFreeMemoryPointer, 32)</span>
 470 |     | <span class='neutral'></span>
 471 |     | <span class='neutral'>            // Clean the last word of memory it may not be overwritten.</span>
 472 |     | <span class='unexecuted'>            mstore(str, 0)</span>
 473 |     | <span class='neutral'></span>
 474 |     | <span class='neutral'>            // Cache the end of the memory to calculate the length later.</span>
 475 |     | <span class='unexecuted'>            let end := str</span>
 476 |     | <span class='neutral'></span>
 477 |     | <span class='neutral'>            // We write the string from rightmost digit to leftmost digit.</span>
 478 |     | <span class='neutral'>            // The following is essentially a do-while loop that also handles the zero case.</span>
 479 |     | <span class='neutral'>            // prettier-ignore</span>
 480 |     | <span class='unexecuted'>            for { let temp := value } 1 {} {</span>
 481 |     | <span class='neutral'>                // Move the pointer 1 byte to the left.</span>
 482 |     | <span class='unexecuted'>                str := sub(str, 1)</span>
 483 |     | <span class='neutral'></span>
 484 |     | <span class='neutral'>                // Write the character to the pointer.</span>
 485 |     | <span class='neutral'>                // The ASCII index of the &#39;0&#39; character is 48.</span>
 486 |     | <span class='unexecuted'>                mstore8(str, add(48, mod(temp, 10)))</span>
 487 |     | <span class='neutral'></span>
 488 |     | <span class='neutral'>                // Keep dividing temp until zero.</span>
 489 |     | <span class='unexecuted'>                temp := div(temp, 10)</span>
 490 |     | <span class='neutral'></span>
 491 |     | <span class='neutral'>                 // prettier-ignore</span>
 492 |     | <span class='unexecuted'>                if iszero(temp) { break }</span>
 493 |     | <span class='neutral'>            }</span>
 494 |     | <span class='neutral'></span>
 495 |     | <span class='neutral'>            // Compute and cache the final total length of the string.</span>
 496 |     | <span class='unexecuted'>            let length := sub(end, str)</span>
 497 |     | <span class='neutral'></span>
 498 |     | <span class='neutral'>            // Move the pointer 32 bytes leftwards to make room for the length.</span>
 499 |     | <span class='unexecuted'>            str := sub(str, 32)</span>
 500 |     | <span class='neutral'></span>
 501 |     | <span class='neutral'>            // Store the string&#39;s length at the start of memory allocated for our string.</span>
 502 |     | <span class='unexecuted'>            mstore(str, length)</span>
 503 |     | <span class='neutral'>        }</span>
 504 |     | <span class='neutral'>    }</span>
 505 |     | <span class='neutral'></span>
 506 |     | <span class='neutral'>    function toString(address value) internal pure returns (string memory str) {</span>
 507 |     | <span class='neutral'>        bytes memory s = new bytes(40);</span>
 508 |     | <span class='neutral'>        for (uint i = 0; i &lt; 20; i++) {</span>
 509 |     | <span class='neutral'>            bytes1 b = bytes1(</span>
 510 |     | <span class='neutral'>                uint8(uint(uint160(value)) / (2 ** (8 * (19 - i))))</span>
 511 |     | <span class='neutral'>            );</span>
 512 |     | <span class='neutral'>            bytes1 hi = bytes1(uint8(b) / 16);</span>
 513 |     | <span class='neutral'>            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));</span>
 514 |     | <span class='neutral'>            s[2 * i] = char(hi);</span>
 515 |     | <span class='neutral'>            s[2 * i + 1] = char(lo);</span>
 516 |     | <span class='neutral'>        }</span>
 517 |     | <span class='neutral'>        return string(s);</span>
 518 |     | <span class='neutral'>    }</span>
 519 |     | <span class='neutral'></span>
 520 |     | <span class='neutral'>    function char(bytes1 b) internal pure returns (bytes1 c) {</span>
 521 |     | <span class='neutral'>        if (uint8(b) &lt; 10) return bytes1(uint8(b) + 0x30);</span>
 522 |     | <span class='neutral'>        else return bytes1(uint8(b) + 0x57);</span>
 523 |     | <span class='neutral'>    }</span>
 524 |     | <span class='neutral'>}</span>
 525 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/access/Ownable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../utils/Context.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Contract module which provides a basic access control mechanism, where</span>
 10 |     | <span class='neutral'> * there is an account (an owner) that can be granted exclusive access to</span>
 11 |     | <span class='neutral'> * specific functions.</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> * By default, the owner account will be the one that deploys the contract. This</span>
 14 |     | <span class='neutral'> * can later be changed with {transferOwnership}.</span>
 15 |     | <span class='neutral'> *</span>
 16 |     | <span class='neutral'> * This module is used through inheritance. It will make available the modifier</span>
 17 |     | <span class='neutral'> * `onlyOwner`, which can be applied to your functions to restrict their use to</span>
 18 |     | <span class='neutral'> * the owner.</span>
 19 |     | <span class='neutral'> */</span>
 20 |     | <span class='neutral'>abstract contract Ownable is Context {</span>
 21 |     | <span class='neutral'>    address private _owner;</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    /**</span>
 26 |     | <span class='neutral'>     * @dev Initializes the contract setting the deployer as the initial owner.</span>
 27 |     | <span class='neutral'>     */</span>
 28 |     | <span class='neutral'>    constructor() {</span>
 29 | *   | <span class='executed'>        _transferOwnership(_msgSender());</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    /**</span>
 33 |     | <span class='neutral'>     * @dev Throws if called by any account other than the owner.</span>
 34 |     | <span class='neutral'>     */</span>
 35 |     | <span class='neutral'>    modifier onlyOwner() {</span>
 36 | *   | <span class='executed'>        _checkOwner();</span>
 37 |     | <span class='neutral'>        _;</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    /**</span>
 41 |     | <span class='neutral'>     * @dev Returns the address of the current owner.</span>
 42 |     | <span class='neutral'>     */</span>
 43 | *   | <span class='executed'>    function owner() public view virtual returns (address) {</span>
 44 | *   | <span class='executed'>        return _owner;</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    /**</span>
 48 |     | <span class='neutral'>     * @dev Throws if the sender is not the owner.</span>
 49 |     | <span class='neutral'>     */</span>
 50 | *   | <span class='executed'>    function _checkOwner() internal view virtual {</span>
 51 | *   | <span class='executed'>        require(owner() == _msgSender(), &quot;Ownable: caller is not the owner&quot;);</span>
 52 |     | <span class='neutral'>    }</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    /**</span>
 55 |     | <span class='neutral'>     * @dev Leaves the contract without owner. It will not be possible to call</span>
 56 |     | <span class='neutral'>     * `onlyOwner` functions anymore. Can only be called by the current owner.</span>
 57 |     | <span class='neutral'>     *</span>
 58 |     | <span class='neutral'>     * NOTE: Renouncing ownership will leave the contract without an owner,</span>
 59 |     | <span class='neutral'>     * thereby removing any functionality that is only available to the owner.</span>
 60 |     | <span class='neutral'>     */</span>
 61 | *   | <span class='executed'>    function renounceOwnership() public virtual onlyOwner {</span>
 62 |     | <span class='unexecuted'>        _transferOwnership(address(0));</span>
 63 |     | <span class='neutral'>    }</span>
 64 |     | <span class='neutral'></span>
 65 |     | <span class='neutral'>    /**</span>
 66 |     | <span class='neutral'>     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span>
 67 |     | <span class='neutral'>     * Can only be called by the current owner.</span>
 68 |     | <span class='neutral'>     */</span>
 69 | *   | <span class='executed'>    function transferOwnership(address newOwner) public virtual onlyOwner {</span>
 70 |     | <span class='unexecuted'>        require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);</span>
 71 |     | <span class='unexecuted'>        _transferOwnership(newOwner);</span>
 72 |     | <span class='neutral'>    }</span>
 73 |     | <span class='neutral'></span>
 74 |     | <span class='neutral'>    /**</span>
 75 |     | <span class='neutral'>     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span>
 76 |     | <span class='neutral'>     * Internal function without access restriction.</span>
 77 |     | <span class='neutral'>     */</span>
 78 | *   | <span class='executed'>    function _transferOwnership(address newOwner) internal virtual {</span>
 79 | *   | <span class='executed'>        address oldOwner = _owner;</span>
 80 | *   | <span class='executed'>        _owner = newOwner;</span>
 81 | *   | <span class='executed'>        emit OwnershipTransferred(oldOwner, newOwner);</span>
 82 |     | <span class='neutral'>    }</span>
 83 |     | <span class='neutral'>}</span>
 84 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/ERC721.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./IERC721.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./IERC721Receiver.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;./extensions/IERC721Metadata.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;../../utils/Address.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;../../utils/Context.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;../../utils/Strings.sol&quot;;</span>
  12 |     | <span class='neutral'>import &quot;../../utils/introspection/ERC165.sol&quot;;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>/**</span>
  15 |     | <span class='neutral'> * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including</span>
  16 |     | <span class='neutral'> * the Metadata extension, but not including the Enumerable extension, which is available separately as</span>
  17 |     | <span class='neutral'> * {ERC721Enumerable}.</span>
  18 |     | <span class='neutral'> */</span>
  19 |     | <span class='unexecuted'>contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {</span>
  20 |     | <span class='neutral'>    using Address for address;</span>
  21 |     | <span class='neutral'>    using Strings for uint256;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    // Token name</span>
  24 |     | <span class='neutral'>    string private _name;</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    // Token symbol</span>
  27 |     | <span class='neutral'>    string private _symbol;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    // Mapping from token ID to owner address</span>
  30 | *   | <span class='executed'>    mapping(uint256 =&gt; address) public _owners;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    // Mapping owner address to token count</span>
  33 | *   | <span class='executed'>    mapping(address =&gt; uint256) public _balances;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    // Mapping from token ID to approved address</span>
  36 | *   | <span class='executed'>    mapping(uint256 =&gt; address) public _tokenApprovals;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    // Mapping from owner to operator approvals</span>
  39 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; bool)) private _operatorApprovals;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /**</span>
  42 |     | <span class='neutral'>     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.</span>
  43 |     | <span class='neutral'>     */</span>
  44 | *   | <span class='executed'>    constructor(string memory name_, string memory symbol_) {</span>
  45 | *   | <span class='executed'>        _name = name_;</span>
  46 | *   | <span class='executed'>        _symbol = symbol_;</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    /**</span>
  50 |     | <span class='neutral'>     * @dev See {IERC165-supportsInterface}.</span>
  51 |     | <span class='neutral'>     */</span>
  52 | *   | <span class='executed'>    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {</span>
  53 |     | <span class='unexecuted'>        return</span>
  54 | *   | <span class='executed'>            interfaceId == type(IERC721).interfaceId ||</span>
  55 | *   | <span class='executed'>            interfaceId == type(IERC721Metadata).interfaceId ||</span>
  56 | *   | <span class='executed'>            super.supportsInterface(interfaceId);</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>     * @dev See {IERC721-balanceOf}.</span>
  61 |     | <span class='neutral'>     */</span>
  62 | *   | <span class='executed'>    function balanceOf(address owner) public view virtual override returns (uint256) {</span>
  63 | *   | <span class='executed'>        require(owner != address(0), &quot;ERC721: address zero is not a valid owner&quot;);</span>
  64 | *   | <span class='executed'>        return _balances[owner];</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    /**</span>
  68 |     | <span class='neutral'>     * @dev See {IERC721-ownerOf}.</span>
  69 |     | <span class='neutral'>     */</span>
  70 | *   | <span class='executed'>    function ownerOf(uint256 tokenId) public view virtual override returns (address) {</span>
  71 |     | <span class='neutral'>        address owner = _ownerOf(tokenId);</span>
  72 | *   | <span class='executed'>        require(owner != address(0), &quot;ERC721: invalid token ID&quot;);</span>
  73 |     | <span class='neutral'>        return owner;</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    /**</span>
  77 |     | <span class='neutral'>     * @dev See {IERC721Metadata-name}.</span>
  78 |     | <span class='neutral'>     */</span>
  79 | *   | <span class='executed'>    function name() public view virtual override returns (string memory) {</span>
  80 | *   | <span class='executed'>        return _name;</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    /**</span>
  84 |     | <span class='neutral'>     * @dev See {IERC721Metadata-symbol}.</span>
  85 |     | <span class='neutral'>     */</span>
  86 | *   | <span class='executed'>    function symbol() public view virtual override returns (string memory) {</span>
  87 | *   | <span class='executed'>        return _symbol;</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    /**</span>
  91 |     | <span class='neutral'>     * @dev See {IERC721Metadata-tokenURI}.</span>
  92 |     | <span class='neutral'>     */</span>
  93 | *   | <span class='executed'>    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {</span>
  94 | *   | <span class='executed'>        _requireMinted(tokenId);</span>
  95 |     | <span class='neutral'></span>
  96 | *   | <span class='executed'>        string memory baseURI = _baseURI();</span>
  97 | *   | <span class='executed'>        return bytes(baseURI).length &gt; 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : &quot;&quot;;</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    /**</span>
 101 |     | <span class='neutral'>     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each</span>
 102 |     | <span class='neutral'>     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty</span>
 103 |     | <span class='neutral'>     * by default, can be overridden in child contracts.</span>
 104 |     | <span class='neutral'>     */</span>
 105 | *   | <span class='executed'>    function _baseURI() internal view virtual returns (string memory) {</span>
 106 | *   | <span class='executed'>        return &quot;&quot;;</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    /**</span>
 110 |     | <span class='neutral'>     * @dev See {IERC721-approve}.</span>
 111 |     | <span class='neutral'>     */</span>
 112 | *   | <span class='executed'>    function approve(address to, uint256 tokenId) public virtual override {</span>
 113 | *   | <span class='executed'>        address owner = ERC721.ownerOf(tokenId);</span>
 114 | *r  | <span class='executed'>        require(to != owner, &quot;ERC721: approval to current owner&quot;);</span>
 115 |     | <span class='neutral'></span>
 116 | *   | <span class='executed'>        require(</span>
 117 | *   | <span class='executed'>            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),</span>
 118 |     | <span class='neutral'>            &quot;ERC721: approve caller is not token owner or approved for all&quot;</span>
 119 |     | <span class='neutral'>        );</span>
 120 |     | <span class='neutral'></span>
 121 | *   | <span class='executed'>        _approve(to, tokenId);</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>    /**</span>
 125 |     | <span class='neutral'>     * @dev See {IERC721-getApproved}.</span>
 126 |     | <span class='neutral'>     */</span>
 127 | *   | <span class='executed'>    function getApproved(uint256 tokenId) public view virtual override returns (address) {</span>
 128 | *   | <span class='executed'>        _requireMinted(tokenId);</span>
 129 |     | <span class='neutral'></span>
 130 | *   | <span class='executed'>        return _tokenApprovals[tokenId];</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>    /**</span>
 134 |     | <span class='neutral'>     * @dev See {IERC721-setApprovalForAll}.</span>
 135 |     | <span class='neutral'>     */</span>
 136 | *   | <span class='executed'>    function setApprovalForAll(address operator, bool approved) public virtual override {</span>
 137 | *   | <span class='executed'>        _setApprovalForAll(_msgSender(), operator, approved);</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    /**</span>
 141 |     | <span class='neutral'>     * @dev See {IERC721-isApprovedForAll}.</span>
 142 |     | <span class='neutral'>     */</span>
 143 | *   | <span class='executed'>    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {</span>
 144 | *   | <span class='executed'>        return _operatorApprovals[owner][operator];</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    /**</span>
 148 |     | <span class='neutral'>     * @dev See {IERC721-transferFrom}.</span>
 149 |     | <span class='neutral'>     */</span>
 150 | *   | <span class='executed'>    function transferFrom(address from, address to, uint256 tokenId) public virtual override {</span>
 151 |     | <span class='neutral'>        //solhint-disable-next-line max-line-length</span>
 152 | *   | <span class='executed'>        require(_isApprovedOrOwner(_msgSender(), tokenId), &quot;ERC721: caller is not token owner or approved&quot;);</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='unexecuted'>        _transfer(from, to, tokenId);</span>
 155 |     | <span class='neutral'>    }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>    /**</span>
 158 |     | <span class='neutral'>     * @dev See {IERC721-safeTransferFrom}.</span>
 159 |     | <span class='neutral'>     */</span>
 160 | *   | <span class='executed'>    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {</span>
 161 | *   | <span class='executed'>        safeTransferFrom(from, to, tokenId, &quot;&quot;);</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    /**</span>
 165 |     | <span class='neutral'>     * @dev See {IERC721-safeTransferFrom}.</span>
 166 |     | <span class='neutral'>     */</span>
 167 | *   | <span class='executed'>    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {</span>
 168 | *   | <span class='executed'>        require(_isApprovedOrOwner(_msgSender(), tokenId), &quot;ERC721: caller is not token owner or approved&quot;);</span>
 169 | *   | <span class='executed'>        _safeTransfer(from, to, tokenId, data);</span>
 170 |     | <span class='neutral'>    }</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'>    /**</span>
 173 |     | <span class='neutral'>     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients</span>
 174 |     | <span class='neutral'>     * are aware of the ERC721 protocol to prevent tokens from being forever locked.</span>
 175 |     | <span class='neutral'>     *</span>
 176 |     | <span class='neutral'>     * `data` is additional data, it has no specified format and it is sent in call to `to`.</span>
 177 |     | <span class='neutral'>     *</span>
 178 |     | <span class='neutral'>     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.</span>
 179 |     | <span class='neutral'>     * implement alternative mechanisms to perform token transfer, such as signature-based.</span>
 180 |     | <span class='neutral'>     *</span>
 181 |     | <span class='neutral'>     * Requirements:</span>
 182 |     | <span class='neutral'>     *</span>
 183 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
 184 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 185 |     | <span class='neutral'>     * - `tokenId` token must exist and be owned by `from`.</span>
 186 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.</span>
 187 |     | <span class='neutral'>     *</span>
 188 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 189 |     | <span class='neutral'>     */</span>
 190 |     | <span class='unexecuted'>    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {</span>
 191 |     | <span class='unexecuted'>        _transfer(from, to, tokenId);</span>
 192 |     | <span class='unexecuted'>        require(_checkOnERC721Received(from, to, tokenId, data), &quot;ERC721: transfer to non ERC721Receiver implementer&quot;);</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>    /**</span>
 196 |     | <span class='neutral'>     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn&#39;t exist</span>
 197 |     | <span class='neutral'>     */</span>
 198 |     | <span class='neutral'>    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {</span>
 199 | *   | <span class='executed'>        return _owners[tokenId];</span>
 200 |     | <span class='neutral'>    }</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>    /**</span>
 203 |     | <span class='neutral'>     * @dev Returns whether `tokenId` exists.</span>
 204 |     | <span class='neutral'>     *</span>
 205 |     | <span class='neutral'>     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.</span>
 206 |     | <span class='neutral'>     *</span>
 207 |     | <span class='neutral'>     * Tokens start existing when they are minted (`_mint`),</span>
 208 |     | <span class='neutral'>     * and stop existing when they are burned (`_burn`).</span>
 209 |     | <span class='neutral'>     */</span>
 210 | *   | <span class='executed'>    function _exists(uint256 tokenId) internal view virtual returns (bool) {</span>
 211 | *   | <span class='executed'>        return _ownerOf(tokenId) != address(0);</span>
 212 |     | <span class='neutral'>    }</span>
 213 |     | <span class='neutral'></span>
 214 |     | <span class='neutral'>    /**</span>
 215 |     | <span class='neutral'>     * @dev Returns whether `spender` is allowed to manage `tokenId`.</span>
 216 |     | <span class='neutral'>     *</span>
 217 |     | <span class='neutral'>     * Requirements:</span>
 218 |     | <span class='neutral'>     *</span>
 219 |     | <span class='neutral'>     * - `tokenId` must exist.</span>
 220 |     | <span class='neutral'>     */</span>
 221 | *   | <span class='executed'>    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {</span>
 222 | *   | <span class='executed'>        address owner = ERC721.ownerOf(tokenId);</span>
 223 | *   | <span class='executed'>        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);</span>
 224 |     | <span class='neutral'>    }</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>    /**</span>
 227 |     | <span class='neutral'>     * @dev Safely mints `tokenId` and transfers it to `to`.</span>
 228 |     | <span class='neutral'>     *</span>
 229 |     | <span class='neutral'>     * Requirements:</span>
 230 |     | <span class='neutral'>     *</span>
 231 |     | <span class='neutral'>     * - `tokenId` must not exist.</span>
 232 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.</span>
 233 |     | <span class='neutral'>     *</span>
 234 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 235 |     | <span class='neutral'>     */</span>
 236 |     | <span class='neutral'>    function _safeMint(address to, uint256 tokenId) internal virtual {</span>
 237 |     | <span class='neutral'>        _safeMint(to, tokenId, &quot;&quot;);</span>
 238 |     | <span class='neutral'>    }</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='neutral'>    /**</span>
 241 |     | <span class='neutral'>     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is</span>
 242 |     | <span class='neutral'>     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.</span>
 243 |     | <span class='neutral'>     */</span>
 244 |     | <span class='neutral'>    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {</span>
 245 |     | <span class='neutral'>        _mint(to, tokenId);</span>
 246 |     | <span class='neutral'>        require(</span>
 247 |     | <span class='neutral'>            _checkOnERC721Received(address(0), to, tokenId, data),</span>
 248 |     | <span class='neutral'>            &quot;ERC721: transfer to non ERC721Receiver implementer&quot;</span>
 249 |     | <span class='neutral'>        );</span>
 250 |     | <span class='neutral'>    }</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='neutral'>    /**</span>
 253 |     | <span class='neutral'>     * @dev Mints `tokenId` and transfers it to `to`.</span>
 254 |     | <span class='neutral'>     *</span>
 255 |     | <span class='neutral'>     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible</span>
 256 |     | <span class='neutral'>     *</span>
 257 |     | <span class='neutral'>     * Requirements:</span>
 258 |     | <span class='neutral'>     *</span>
 259 |     | <span class='neutral'>     * - `tokenId` must not exist.</span>
 260 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 261 |     | <span class='neutral'>     *</span>
 262 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 263 |     | <span class='neutral'>     */</span>
 264 | *   | <span class='executed'>    function _mint(address to, uint256 tokenId) internal virtual {</span>
 265 | *   | <span class='executed'>        require(to != address(0), &quot;ERC721: mint to the zero address&quot;);</span>
 266 | *   | <span class='executed'>        require(!_exists(tokenId), &quot;ERC721: token already minted&quot;);</span>
 267 |     | <span class='neutral'></span>
 268 | *   | <span class='executed'>        _beforeTokenTransfer(address(0), to, tokenId, 1);</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='neutral'>        // Check that tokenId was not minted by `_beforeTokenTransfer` hook</span>
 271 | *   | <span class='executed'>        require(!_exists(tokenId), &quot;ERC721: token already minted&quot;);</span>
 272 |     | <span class='neutral'></span>
 273 |     | <span class='neutral'>        unchecked {</span>
 274 |     | <span class='neutral'>            // Will not overflow unless all 2**256 token ids are minted to the same owner.</span>
 275 |     | <span class='neutral'>            // Given that tokens are minted one by one, it is impossible in practice that</span>
 276 |     | <span class='neutral'>            // this ever happens. Might change if we allow batch minting.</span>
 277 |     | <span class='neutral'>            // The ERC fails to describe this case.</span>
 278 | *   | <span class='executed'>            _balances[to] += 1;</span>
 279 |     | <span class='neutral'>        }</span>
 280 |     | <span class='neutral'></span>
 281 | *o  | <span class='executed'>        _owners[tokenId] = to;</span>
 282 |     | <span class='neutral'></span>
 283 | *o  | <span class='executed'>        emit Transfer(address(0), to, tokenId);</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='neutral'>        _afterTokenTransfer(address(0), to, tokenId, 1);</span>
 286 |     | <span class='neutral'>    }</span>
 287 |     | <span class='neutral'></span>
 288 |     | <span class='neutral'>    /**</span>
 289 |     | <span class='neutral'>     * @dev Destroys `tokenId`.</span>
 290 |     | <span class='neutral'>     * The approval is cleared when the token is burned.</span>
 291 |     | <span class='neutral'>     * This is an internal function that does not check if the sender is authorized to operate on the token.</span>
 292 |     | <span class='neutral'>     *</span>
 293 |     | <span class='neutral'>     * Requirements:</span>
 294 |     | <span class='neutral'>     *</span>
 295 |     | <span class='neutral'>     * - `tokenId` must exist.</span>
 296 |     | <span class='neutral'>     *</span>
 297 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 298 |     | <span class='neutral'>     */</span>
 299 | *   | <span class='executed'>    function _burn(uint256 tokenId) internal virtual {</span>
 300 | *   | <span class='executed'>        address owner = ERC721.ownerOf(tokenId);</span>
 301 |     | <span class='neutral'></span>
 302 | *   | <span class='executed'>        _beforeTokenTransfer(owner, address(0), tokenId, 1);</span>
 303 |     | <span class='neutral'></span>
 304 |     | <span class='neutral'>        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook</span>
 305 | *   | <span class='executed'>        owner = ERC721.ownerOf(tokenId);</span>
 306 |     | <span class='neutral'></span>
 307 |     | <span class='neutral'>        // Clear approvals</span>
 308 | *   | <span class='executed'>        delete _tokenApprovals[tokenId];</span>
 309 |     | <span class='neutral'></span>
 310 |     | <span class='neutral'>        unchecked {</span>
 311 |     | <span class='neutral'>            // Cannot overflow, as that would require more tokens to be burned/transferred</span>
 312 |     | <span class='neutral'>            // out than the owner initially received through minting and transferring in.</span>
 313 | *   | <span class='executed'>            _balances[owner] -= 1;</span>
 314 |     | <span class='neutral'>        }</span>
 315 | *   | <span class='executed'>        delete _owners[tokenId];</span>
 316 |     | <span class='neutral'></span>
 317 | *   | <span class='executed'>        emit Transfer(owner, address(0), tokenId);</span>
 318 |     | <span class='neutral'></span>
 319 |     | <span class='neutral'>        _afterTokenTransfer(owner, address(0), tokenId, 1);</span>
 320 |     | <span class='neutral'>    }</span>
 321 |     | <span class='neutral'></span>
 322 |     | <span class='neutral'>    /**</span>
 323 |     | <span class='neutral'>     * @dev Transfers `tokenId` from `from` to `to`.</span>
 324 |     | <span class='neutral'>     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.</span>
 325 |     | <span class='neutral'>     *</span>
 326 |     | <span class='neutral'>     * Requirements:</span>
 327 |     | <span class='neutral'>     *</span>
 328 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 329 |     | <span class='neutral'>     * - `tokenId` token must be owned by `from`.</span>
 330 |     | <span class='neutral'>     *</span>
 331 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 332 |     | <span class='neutral'>     */</span>
 333 |     | <span class='unexecuted'>    function _transfer(address from, address to, uint256 tokenId) internal virtual {</span>
 334 |     | <span class='unexecuted'>        require(ERC721.ownerOf(tokenId) == from, &quot;ERC721: transfer from incorrect owner&quot;);</span>
 335 |     | <span class='unexecuted'>        require(to != address(0), &quot;ERC721: transfer to the zero address&quot;);</span>
 336 |     | <span class='neutral'></span>
 337 |     | <span class='unexecuted'>        _beforeTokenTransfer(from, to, tokenId, 1);</span>
 338 |     | <span class='neutral'></span>
 339 |     | <span class='neutral'>        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook</span>
 340 |     | <span class='unexecuted'>        require(ERC721.ownerOf(tokenId) == from, &quot;ERC721: transfer from incorrect owner&quot;);</span>
 341 |     | <span class='neutral'></span>
 342 |     | <span class='neutral'>        // Clear approvals from the previous owner</span>
 343 |     | <span class='unexecuted'>        delete _tokenApprovals[tokenId];</span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='neutral'>        unchecked {</span>
 346 |     | <span class='neutral'>            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:</span>
 347 |     | <span class='neutral'>            // `from`&#39;s balance is the number of token held, which is at least one before the current</span>
 348 |     | <span class='neutral'>            // transfer.</span>
 349 |     | <span class='neutral'>            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require</span>
 350 |     | <span class='neutral'>            // all 2**256 token ids to be minted, which in practice is impossible.</span>
 351 |     | <span class='unexecuted'>            _balances[from] -= 1;</span>
 352 |     | <span class='unexecuted'>            _balances[to] += 1;</span>
 353 |     | <span class='neutral'>        }</span>
 354 |     | <span class='unexecuted'>        _owners[tokenId] = to;</span>
 355 |     | <span class='neutral'></span>
 356 |     | <span class='unexecuted'>        emit Transfer(from, to, tokenId);</span>
 357 |     | <span class='neutral'></span>
 358 |     | <span class='neutral'>        _afterTokenTransfer(from, to, tokenId, 1);</span>
 359 |     | <span class='neutral'>    }</span>
 360 |     | <span class='neutral'></span>
 361 |     | <span class='neutral'>    /**</span>
 362 |     | <span class='neutral'>     * @dev Approve `to` to operate on `tokenId`</span>
 363 |     | <span class='neutral'>     *</span>
 364 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 365 |     | <span class='neutral'>     */</span>
 366 |     | <span class='unexecuted'>    function _approve(address to, uint256 tokenId) internal virtual {</span>
 367 |     | <span class='unexecuted'>        _tokenApprovals[tokenId] = to;</span>
 368 |     | <span class='unexecuted'>        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);</span>
 369 |     | <span class='neutral'>    }</span>
 370 |     | <span class='neutral'></span>
 371 |     | <span class='neutral'>    /**</span>
 372 |     | <span class='neutral'>     * @dev Approve `operator` to operate on all of `owner` tokens</span>
 373 |     | <span class='neutral'>     *</span>
 374 |     | <span class='neutral'>     * Emits an {ApprovalForAll} event.</span>
 375 |     | <span class='neutral'>     */</span>
 376 | *   | <span class='executed'>    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {</span>
 377 | *   | <span class='executed'>        require(owner != operator, &quot;ERC721: approve to caller&quot;);</span>
 378 | *   | <span class='executed'>        _operatorApprovals[owner][operator] = approved;</span>
 379 | *   | <span class='executed'>        emit ApprovalForAll(owner, operator, approved);</span>
 380 |     | <span class='neutral'>    }</span>
 381 |     | <span class='neutral'></span>
 382 |     | <span class='neutral'>    /**</span>
 383 |     | <span class='neutral'>     * @dev Reverts if the `tokenId` has not been minted yet.</span>
 384 |     | <span class='neutral'>     */</span>
 385 | *   | <span class='executed'>    function _requireMinted(uint256 tokenId) internal view virtual {</span>
 386 | *   | <span class='executed'>        require(_exists(tokenId), &quot;ERC721: invalid token ID&quot;);</span>
 387 |     | <span class='neutral'>    }</span>
 388 |     | <span class='neutral'></span>
 389 |     | <span class='neutral'>    /**</span>
 390 |     | <span class='neutral'>     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.</span>
 391 |     | <span class='neutral'>     * The call is not executed if the target address is not a contract.</span>
 392 |     | <span class='neutral'>     *</span>
 393 |     | <span class='neutral'>     * @param from address representing the previous owner of the given token ID</span>
 394 |     | <span class='neutral'>     * @param to target address that will receive the tokens</span>
 395 |     | <span class='neutral'>     * @param tokenId uint256 ID of the token to be transferred</span>
 396 |     | <span class='neutral'>     * @param data bytes optional data to send along with the call</span>
 397 |     | <span class='neutral'>     * @return bool whether the call correctly returned the expected magic value</span>
 398 |     | <span class='neutral'>     */</span>
 399 |     | <span class='unexecuted'>    function _checkOnERC721Received(</span>
 400 |     | <span class='neutral'>        address from,</span>
 401 |     | <span class='neutral'>        address to,</span>
 402 |     | <span class='neutral'>        uint256 tokenId,</span>
 403 |     | <span class='neutral'>        bytes memory data</span>
 404 |     | <span class='unexecuted'>    ) private returns (bool) {</span>
 405 |     | <span class='unexecuted'>        if (to.isContract()) {</span>
 406 |     | <span class='unexecuted'>            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {</span>
 407 |     | <span class='unexecuted'>                return retval == IERC721Receiver.onERC721Received.selector;</span>
 408 |     | <span class='neutral'>            } catch (bytes memory reason) {</span>
 409 |     | <span class='unexecuted'>                if (reason.length == 0) {</span>
 410 |     | <span class='unexecuted'>                    revert(&quot;ERC721: transfer to non ERC721Receiver implementer&quot;);</span>
 411 |     | <span class='neutral'>                } else {</span>
 412 |     | <span class='neutral'>                    /// @solidity memory-safe-assembly</span>
 413 |     | <span class='neutral'>                    assembly {</span>
 414 |     | <span class='unexecuted'>                        revert(add(32, reason), mload(reason))</span>
 415 |     | <span class='neutral'>                    }</span>
 416 |     | <span class='neutral'>                }</span>
 417 |     | <span class='neutral'>            }</span>
 418 |     | <span class='neutral'>        } else {</span>
 419 |     | <span class='unexecuted'>            return true;</span>
 420 |     | <span class='neutral'>        }</span>
 421 |     | <span class='neutral'>    }</span>
 422 |     | <span class='neutral'></span>
 423 |     | <span class='neutral'>    /**</span>
 424 |     | <span class='neutral'>     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is</span>
 425 |     | <span class='neutral'>     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.</span>
 426 |     | <span class='neutral'>     *</span>
 427 |     | <span class='neutral'>     * Calling conditions:</span>
 428 |     | <span class='neutral'>     *</span>
 429 |     | <span class='neutral'>     * - When `from` and `to` are both non-zero, ``from``&#39;s tokens will be transferred to `to`.</span>
 430 |     | <span class='neutral'>     * - When `from` is zero, the tokens will be minted for `to`.</span>
 431 |     | <span class='neutral'>     * - When `to` is zero, ``from``&#39;s tokens will be burned.</span>
 432 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 433 |     | <span class='neutral'>     * - `batchSize` is non-zero.</span>
 434 |     | <span class='neutral'>     *</span>
 435 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 436 |     | <span class='neutral'>     */</span>
 437 | *   | <span class='executed'>    function _beforeTokenTransfer(</span>
 438 |     | <span class='neutral'>        address from,</span>
 439 |     | <span class='neutral'>        address to,</span>
 440 |     | <span class='neutral'>        uint256 /* firstTokenId */,</span>
 441 |     | <span class='neutral'>        uint256 batchSize</span>
 442 |     | <span class='neutral'>    ) internal virtual {</span>
 443 | *   | <span class='executed'>        if (batchSize &gt; 1) {</span>
 444 |     | <span class='unexecuted'>            if (from != address(0)) {</span>
 445 |     | <span class='unexecuted'>                _balances[from] -= batchSize;</span>
 446 |     | <span class='neutral'>            }</span>
 447 |     | <span class='unexecuted'>            if (to != address(0)) {</span>
 448 |     | <span class='unexecuted'>                _balances[to] += batchSize;</span>
 449 |     | <span class='neutral'>            }</span>
 450 |     | <span class='neutral'>        }</span>
 451 |     | <span class='neutral'>    }</span>
 452 |     | <span class='neutral'></span>
 453 |     | <span class='neutral'>    /**</span>
 454 |     | <span class='neutral'>     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is</span>
 455 |     | <span class='neutral'>     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.</span>
 456 |     | <span class='neutral'>     *</span>
 457 |     | <span class='neutral'>     * Calling conditions:</span>
 458 |     | <span class='neutral'>     *</span>
 459 |     | <span class='neutral'>     * - When `from` and `to` are both non-zero, ``from``&#39;s tokens were transferred to `to`.</span>
 460 |     | <span class='neutral'>     * - When `from` is zero, the tokens were minted for `to`.</span>
 461 |     | <span class='neutral'>     * - When `to` is zero, ``from``&#39;s tokens were burned.</span>
 462 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 463 |     | <span class='neutral'>     * - `batchSize` is non-zero.</span>
 464 |     | <span class='neutral'>     *</span>
 465 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 466 |     | <span class='neutral'>     */</span>
 467 |     | <span class='neutral'>    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}</span>
 468 |     | <span class='neutral'>}</span>
 469 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;../../utils/introspection/IERC165.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/**</span>
   9 |     | <span class='neutral'> * @dev Required interface of an ERC721 compliant contract.</span>
  10 |     | <span class='neutral'> */</span>
  11 |     | <span class='neutral'>interface IERC721 is IERC165 {</span>
  12 |     | <span class='neutral'>    /**</span>
  13 |     | <span class='neutral'>     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.</span>
  14 |     | <span class='neutral'>     */</span>
  15 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /**</span>
  18 |     | <span class='neutral'>     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.</span>
  19 |     | <span class='neutral'>     */</span>
  20 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    /**</span>
  23 |     | <span class='neutral'>     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.</span>
  24 |     | <span class='neutral'>     */</span>
  25 |     | <span class='neutral'>    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /**</span>
  28 |     | <span class='neutral'>     * @dev Returns the number of tokens in ``owner``&#39;s account.</span>
  29 |     | <span class='neutral'>     */</span>
  30 |     | <span class='neutral'>    function balanceOf(address owner) external view returns (uint256 balance);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    /**</span>
  33 |     | <span class='neutral'>     * @dev Returns the owner of the `tokenId` token.</span>
  34 |     | <span class='neutral'>     *</span>
  35 |     | <span class='neutral'>     * Requirements:</span>
  36 |     | <span class='neutral'>     *</span>
  37 |     | <span class='neutral'>     * - `tokenId` must exist.</span>
  38 |     | <span class='neutral'>     */</span>
  39 |     | <span class='neutral'>    function ownerOf(uint256 tokenId) external view returns (address owner);</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /**</span>
  42 |     | <span class='neutral'>     * @dev Safely transfers `tokenId` token from `from` to `to`.</span>
  43 |     | <span class='neutral'>     *</span>
  44 |     | <span class='neutral'>     * Requirements:</span>
  45 |     | <span class='neutral'>     *</span>
  46 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
  47 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
  48 |     | <span class='neutral'>     * - `tokenId` token must exist and be owned by `from`.</span>
  49 |     | <span class='neutral'>     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.</span>
  50 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.</span>
  51 |     | <span class='neutral'>     *</span>
  52 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
  53 |     | <span class='neutral'>     */</span>
  54 |     | <span class='neutral'>    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /**</span>
  57 |     | <span class='neutral'>     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients</span>
  58 |     | <span class='neutral'>     * are aware of the ERC721 protocol to prevent tokens from being forever locked.</span>
  59 |     | <span class='neutral'>     *</span>
  60 |     | <span class='neutral'>     * Requirements:</span>
  61 |     | <span class='neutral'>     *</span>
  62 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
  63 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
  64 |     | <span class='neutral'>     * - `tokenId` token must exist and be owned by `from`.</span>
  65 |     | <span class='neutral'>     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.</span>
  66 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.</span>
  67 |     | <span class='neutral'>     *</span>
  68 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
  69 |     | <span class='neutral'>     */</span>
  70 |     | <span class='neutral'>    function safeTransferFrom(address from, address to, uint256 tokenId) external;</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    /**</span>
  73 |     | <span class='neutral'>     * @dev Transfers `tokenId` token from `from` to `to`.</span>
  74 |     | <span class='neutral'>     *</span>
  75 |     | <span class='neutral'>     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721</span>
  76 |     | <span class='neutral'>     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must</span>
  77 |     | <span class='neutral'>     * understand this adds an external call which potentially creates a reentrancy vulnerability.</span>
  78 |     | <span class='neutral'>     *</span>
  79 |     | <span class='neutral'>     * Requirements:</span>
  80 |     | <span class='neutral'>     *</span>
  81 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
  82 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
  83 |     | <span class='neutral'>     * - `tokenId` token must be owned by `from`.</span>
  84 |     | <span class='neutral'>     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.</span>
  85 |     | <span class='neutral'>     *</span>
  86 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
  87 |     | <span class='neutral'>     */</span>
  88 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 tokenId) external;</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    /**</span>
  91 |     | <span class='neutral'>     * @dev Gives permission to `to` to transfer `tokenId` token to another account.</span>
  92 |     | <span class='neutral'>     * The approval is cleared when the token is transferred.</span>
  93 |     | <span class='neutral'>     *</span>
  94 |     | <span class='neutral'>     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.</span>
  95 |     | <span class='neutral'>     *</span>
  96 |     | <span class='neutral'>     * Requirements:</span>
  97 |     | <span class='neutral'>     *</span>
  98 |     | <span class='neutral'>     * - The caller must own the token or be an approved operator.</span>
  99 |     | <span class='neutral'>     * - `tokenId` must exist.</span>
 100 |     | <span class='neutral'>     *</span>
 101 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 102 |     | <span class='neutral'>     */</span>
 103 |     | <span class='neutral'>    function approve(address to, uint256 tokenId) external;</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    /**</span>
 106 |     | <span class='neutral'>     * @dev Approve or remove `operator` as an operator for the caller.</span>
 107 |     | <span class='neutral'>     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.</span>
 108 |     | <span class='neutral'>     *</span>
 109 |     | <span class='neutral'>     * Requirements:</span>
 110 |     | <span class='neutral'>     *</span>
 111 |     | <span class='neutral'>     * - The `operator` cannot be the caller.</span>
 112 |     | <span class='neutral'>     *</span>
 113 |     | <span class='neutral'>     * Emits an {ApprovalForAll} event.</span>
 114 |     | <span class='neutral'>     */</span>
 115 |     | <span class='neutral'>    function setApprovalForAll(address operator, bool approved) external;</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>    /**</span>
 118 |     | <span class='neutral'>     * @dev Returns the account approved for `tokenId` token.</span>
 119 |     | <span class='neutral'>     *</span>
 120 |     | <span class='neutral'>     * Requirements:</span>
 121 |     | <span class='neutral'>     *</span>
 122 |     | <span class='neutral'>     * - `tokenId` must exist.</span>
 123 |     | <span class='neutral'>     */</span>
 124 |     | <span class='neutral'>    function getApproved(uint256 tokenId) external view returns (address operator);</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /**</span>
 127 |     | <span class='neutral'>     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.</span>
 128 |     | <span class='neutral'>     *</span>
 129 |     | <span class='neutral'>     * See {setApprovalForAll}</span>
 130 |     | <span class='neutral'>     */</span>
 131 |     | <span class='neutral'>    function isApprovedForAll(address owner, address operator) external view returns (bool);</span>
 132 |     | <span class='neutral'>}</span>
 133 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @title ERC721 token receiver interface</span>
  8 |     | <span class='neutral'> * @dev Interface for any contract that wants to support safeTransfers</span>
  9 |     | <span class='neutral'> * from ERC721 asset contracts.</span>
 10 |     | <span class='neutral'> */</span>
 11 |     | <span class='neutral'>interface IERC721Receiver {</span>
 12 |     | <span class='neutral'>    /**</span>
 13 |     | <span class='neutral'>     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}</span>
 14 |     | <span class='neutral'>     * by `operator` from `from`, this function is called.</span>
 15 |     | <span class='neutral'>     *</span>
 16 |     | <span class='neutral'>     * It must return its Solidity selector to confirm the token transfer.</span>
 17 |     | <span class='neutral'>     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.</span>
 18 |     | <span class='neutral'>     *</span>
 19 |     | <span class='neutral'>     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.</span>
 20 |     | <span class='neutral'>     */</span>
 21 |     | <span class='neutral'>    function onERC721Received(</span>
 22 |     | <span class='neutral'>        address operator,</span>
 23 |     | <span class='neutral'>        address from,</span>
 24 |     | <span class='neutral'>        uint256 tokenId,</span>
 25 |     | <span class='neutral'>        bytes calldata data</span>
 26 |     | <span class='neutral'>    ) external returns (bytes4);</span>
 27 |     | <span class='neutral'>}</span>
 28 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/token/ERC721/extensions/ERC721Burnable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Burnable.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../ERC721.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../../../utils/Context.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/**</span>
 10 |     | <span class='neutral'> * @title ERC721 Burnable Token</span>
 11 |     | <span class='neutral'> * @dev ERC721 Token that can be burned (destroyed).</span>
 12 |     | <span class='neutral'> */</span>
 13 |     | <span class='neutral'>abstract contract ERC721Burnable is Context, ERC721 {</span>
 14 |     | <span class='neutral'>    /**</span>
 15 |     | <span class='neutral'>     * @dev Burns `tokenId`. See {ERC721-_burn}.</span>
 16 |     | <span class='neutral'>     *</span>
 17 |     | <span class='neutral'>     * Requirements:</span>
 18 |     | <span class='neutral'>     *</span>
 19 |     | <span class='neutral'>     * - The caller must own `tokenId` or be an approved operator.</span>
 20 |     | <span class='neutral'>     */</span>
 21 | *   | <span class='executed'>    function burn(uint256 tokenId) public virtual {</span>
 22 |     | <span class='neutral'>        //solhint-disable-next-line max-line-length</span>
 23 | *   | <span class='executed'>        require(_isApprovedOrOwner(_msgSender(), tokenId), &quot;ERC721: caller is not token owner or approved&quot;);</span>
 24 | *   | <span class='executed'>        _burn(tokenId);</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'>}</span>
 27 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/token/ERC721/extensions/ERC721Enumerable.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Enumerable.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;../ERC721.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./IERC721Enumerable.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>/**</span>
  10 |     | <span class='neutral'> * @dev This implements an optional extension of {ERC721} defined in the EIP that adds</span>
  11 |     | <span class='neutral'> * enumerability of all the token ids in the contract as well as all token ids owned by each</span>
  12 |     | <span class='neutral'> * account.</span>
  13 |     | <span class='neutral'> */</span>
  14 |     | <span class='neutral'>abstract contract ERC721Enumerable is ERC721, IERC721Enumerable {</span>
  15 |     | <span class='neutral'>    // Mapping from owner to list of owned token IDs</span>
  16 |     | <span class='neutral'>    mapping(address =&gt; mapping(uint256 =&gt; uint256)) private _ownedTokens;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    // Mapping from token ID to index of the owner tokens list</span>
  19 |     | <span class='neutral'>    mapping(uint256 =&gt; uint256) private _ownedTokensIndex;</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    // Array with all token ids, used for enumeration</span>
  22 |     | <span class='neutral'>    uint256[] private _allTokens;</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    // Mapping from token id to position in the allTokens array</span>
  25 |     | <span class='neutral'>    mapping(uint256 =&gt; uint256) private _allTokensIndex;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /**</span>
  28 |     | <span class='neutral'>     * @dev See {IERC165-supportsInterface}.</span>
  29 |     | <span class='neutral'>     */</span>
  30 | *   | <span class='executed'>    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {</span>
  31 | *   | <span class='executed'>        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);</span>
  32 |     | <span class='neutral'>    }</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    /**</span>
  35 |     | <span class='neutral'>     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.</span>
  36 |     | <span class='neutral'>     */</span>
  37 | *   | <span class='executed'>    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {</span>
  38 | *   | <span class='executed'>        require(index &lt; ERC721.balanceOf(owner), &quot;ERC721Enumerable: owner index out of bounds&quot;);</span>
  39 | *   | <span class='executed'>        return _ownedTokens[owner][index];</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    /**</span>
  43 |     | <span class='neutral'>     * @dev See {IERC721Enumerable-totalSupply}.</span>
  44 |     | <span class='neutral'>     */</span>
  45 | *   | <span class='executed'>    function totalSupply() public view virtual override returns (uint256) {</span>
  46 | *   | <span class='executed'>        return _allTokens.length;</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    /**</span>
  50 |     | <span class='neutral'>     * @dev See {IERC721Enumerable-tokenByIndex}.</span>
  51 |     | <span class='neutral'>     */</span>
  52 | *   | <span class='executed'>    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {</span>
  53 | *   | <span class='executed'>        require(index &lt; ERC721Enumerable.totalSupply(), &quot;ERC721Enumerable: global index out of bounds&quot;);</span>
  54 | *   | <span class='executed'>        return _allTokens[index];</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    /**</span>
  58 |     | <span class='neutral'>     * @dev See {ERC721-_beforeTokenTransfer}.</span>
  59 |     | <span class='neutral'>     */</span>
  60 | *   | <span class='executed'>    function _beforeTokenTransfer(</span>
  61 |     | <span class='neutral'>        address from,</span>
  62 |     | <span class='neutral'>        address to,</span>
  63 |     | <span class='neutral'>        uint256 firstTokenId,</span>
  64 |     | <span class='neutral'>        uint256 batchSize</span>
  65 | *   | <span class='executed'>    ) internal virtual override {</span>
  66 | *   | <span class='executed'>        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);</span>
  67 |     | <span class='neutral'></span>
  68 | *   | <span class='executed'>        if (batchSize &gt; 1) {</span>
  69 |     | <span class='neutral'>            // Will only trigger during construction. Batch transferring (minting) is not available afterwards.</span>
  70 |     | <span class='unexecuted'>            revert(&quot;ERC721Enumerable: consecutive transfers not supported&quot;);</span>
  71 |     | <span class='neutral'>        }</span>
  72 |     | <span class='neutral'></span>
  73 | *   | <span class='executed'>        uint256 tokenId = firstTokenId;</span>
  74 |     | <span class='neutral'></span>
  75 | *   | <span class='executed'>        if (from == address(0)) {</span>
  76 | *   | <span class='executed'>            _addTokenToAllTokensEnumeration(tokenId);</span>
  77 | *   | <span class='executed'>        } else if (from != to) {</span>
  78 | *   | <span class='executed'>            _removeTokenFromOwnerEnumeration(from, tokenId);</span>
  79 |     | <span class='neutral'>        }</span>
  80 | *   | <span class='executed'>        if (to == address(0)) {</span>
  81 | *   | <span class='executed'>            _removeTokenFromAllTokensEnumeration(tokenId);</span>
  82 | *   | <span class='executed'>        } else if (to != from) {</span>
  83 | *   | <span class='executed'>            _addTokenToOwnerEnumeration(to, tokenId);</span>
  84 |     | <span class='neutral'>        }</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>    /**</span>
  88 |     | <span class='neutral'>     * @dev Private function to add a token to this extension&#39;s ownership-tracking data structures.</span>
  89 |     | <span class='neutral'>     * @param to address representing the new owner of the given token ID</span>
  90 |     | <span class='neutral'>     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address</span>
  91 |     | <span class='neutral'>     */</span>
  92 | *   | <span class='executed'>    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {</span>
  93 | *   | <span class='executed'>        uint256 length = ERC721.balanceOf(to);</span>
  94 | *   | <span class='executed'>        _ownedTokens[to][length] = tokenId;</span>
  95 | *   | <span class='executed'>        _ownedTokensIndex[tokenId] = length;</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /**</span>
  99 |     | <span class='neutral'>     * @dev Private function to add a token to this extension&#39;s token tracking data structures.</span>
 100 |     | <span class='neutral'>     * @param tokenId uint256 ID of the token to be added to the tokens list</span>
 101 |     | <span class='neutral'>     */</span>
 102 | *   | <span class='executed'>    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {</span>
 103 | *o  | <span class='executed'>        _allTokensIndex[tokenId] = _allTokens.length;</span>
 104 | *   | <span class='executed'>        _allTokens.push(tokenId);</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    /**</span>
 108 |     | <span class='neutral'>     * @dev Private function to remove a token from this extension&#39;s ownership-tracking data structures. Note that</span>
 109 |     | <span class='neutral'>     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for</span>
 110 |     | <span class='neutral'>     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).</span>
 111 |     | <span class='neutral'>     * This has O(1) time complexity, but alters the order of the _ownedTokens array.</span>
 112 |     | <span class='neutral'>     * @param from address representing the previous owner of the given token ID</span>
 113 |     | <span class='neutral'>     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address</span>
 114 |     | <span class='neutral'>     */</span>
 115 | *   | <span class='executed'>    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {</span>
 116 |     | <span class='neutral'>        // To prevent a gap in from&#39;s tokens array, we store the last token in the index of the token to delete, and</span>
 117 |     | <span class='neutral'>        // then delete the last slot (swap and pop).</span>
 118 |     | <span class='neutral'></span>
 119 | *   | <span class='executed'>        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;</span>
 120 | *   | <span class='executed'>        uint256 tokenIndex = _ownedTokensIndex[tokenId];</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>        // When the token to delete is the last token, the swap operation is unnecessary</span>
 123 | *   | <span class='executed'>        if (tokenIndex != lastTokenIndex) {</span>
 124 | *   | <span class='executed'>            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];</span>
 125 |     | <span class='neutral'></span>
 126 | *   | <span class='executed'>            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token</span>
 127 | *   | <span class='executed'>            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token&#39;s index</span>
 128 |     | <span class='neutral'>        }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>        // This also deletes the contents at the last position of the array</span>
 131 | *   | <span class='executed'>        delete _ownedTokensIndex[tokenId];</span>
 132 | *   | <span class='executed'>        delete _ownedTokens[from][lastTokenIndex];</span>
 133 |     | <span class='neutral'>    }</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='neutral'>    /**</span>
 136 |     | <span class='neutral'>     * @dev Private function to remove a token from this extension&#39;s token tracking data structures.</span>
 137 |     | <span class='neutral'>     * This has O(1) time complexity, but alters the order of the _allTokens array.</span>
 138 |     | <span class='neutral'>     * @param tokenId uint256 ID of the token to be removed from the tokens list</span>
 139 |     | <span class='neutral'>     */</span>
 140 | *   | <span class='executed'>    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {</span>
 141 |     | <span class='neutral'>        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and</span>
 142 |     | <span class='neutral'>        // then delete the last slot (swap and pop).</span>
 143 |     | <span class='neutral'></span>
 144 | *   | <span class='executed'>        uint256 lastTokenIndex = _allTokens.length - 1;</span>
 145 | *   | <span class='executed'>        uint256 tokenIndex = _allTokensIndex[tokenId];</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so</span>
 148 |     | <span class='neutral'>        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding</span>
 149 |     | <span class='neutral'>        // an &#39;if&#39; statement (like in _removeTokenFromOwnerEnumeration)</span>
 150 | *   | <span class='executed'>        uint256 lastTokenId = _allTokens[lastTokenIndex];</span>
 151 |     | <span class='neutral'></span>
 152 | *   | <span class='executed'>        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token</span>
 153 | *   | <span class='executed'>        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token&#39;s index</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>        // This also deletes the contents at the last position of the array</span>
 156 | *   | <span class='executed'>        delete _allTokensIndex[tokenId];</span>
 157 | *   | <span class='executed'>        _allTokens.pop();</span>
 158 |     | <span class='neutral'>    }</span>
 159 |     | <span class='neutral'>}</span>
 160 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Enumerable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../IERC721.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension</span>
 10 |     | <span class='neutral'> * @dev See https://eips.ethereum.org/EIPS/eip-721</span>
 11 |     | <span class='neutral'> */</span>
 12 |     | <span class='neutral'>interface IERC721Enumerable is IERC721 {</span>
 13 |     | <span class='neutral'>    /**</span>
 14 |     | <span class='neutral'>     * @dev Returns the total amount of tokens stored by the contract.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.</span>
 20 |     | <span class='neutral'>     * Use along with {balanceOf} to enumerate all of ``owner``&#39;s tokens.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.</span>
 26 |     | <span class='neutral'>     * Use along with {totalSupply} to enumerate all tokens.</span>
 27 |     | <span class='neutral'>     */</span>
 28 |     | <span class='neutral'>    function tokenByIndex(uint256 index) external view returns (uint256);</span>
 29 |     | <span class='neutral'>}</span>
 30 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Metadata.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../IERC721.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @title ERC-721 Non-Fungible Token Standard, optional metadata extension</span>
 10 |     | <span class='neutral'> * @dev See https://eips.ethereum.org/EIPS/eip-721</span>
 11 |     | <span class='neutral'> */</span>
 12 |     | <span class='neutral'>interface IERC721Metadata is IERC721 {</span>
 13 |     | <span class='neutral'>    /**</span>
 14 |     | <span class='neutral'>     * @dev Returns the token collection name.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @dev Returns the token collection symbol.</span>
 20 |     | <span class='neutral'>     */</span>
 21 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    /**</span>
 24 |     | <span class='neutral'>     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.</span>
 25 |     | <span class='neutral'>     */</span>
 26 |     | <span class='neutral'>    function tokenURI(uint256 tokenId) external view returns (string memory);</span>
 27 |     | <span class='neutral'>}</span>
 28 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/token/ERC721/utils/ERC721Holder.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../IERC721Receiver.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Implementation of the {IERC721Receiver} interface.</span>
 10 |     | <span class='neutral'> *</span>
 11 |     | <span class='neutral'> * Accepts all token transfers.</span>
 12 |     | <span class='neutral'> * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.</span>
 13 |     | <span class='neutral'> */</span>
 14 |     | <span class='unexecuted'>contract ERC721Holder is IERC721Receiver {</span>
 15 |     | <span class='neutral'>    /**</span>
 16 |     | <span class='neutral'>     * @dev See {IERC721Receiver-onERC721Received}.</span>
 17 |     | <span class='neutral'>     *</span>
 18 |     | <span class='neutral'>     * Always returns `IERC721Receiver.onERC721Received.selector`.</span>
 19 |     | <span class='neutral'>     */</span>
 20 |     | <span class='unexecuted'>    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {</span>
 21 |     | <span class='neutral'>        return this.onERC721Received.selector;</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'>}</span>
 24 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/utils/Address.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.1;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @dev Collection of functions related to the address type</span>
   8 |     | <span class='neutral'> */</span>
   9 |     | <span class='unexecuted'>library Address {</span>
  10 |     | <span class='neutral'>    /**</span>
  11 |     | <span class='neutral'>     * @dev Returns true if `account` is a contract.</span>
  12 |     | <span class='neutral'>     *</span>
  13 |     | <span class='neutral'>     * [IMPORTANT]</span>
  14 |     | <span class='neutral'>     * ====</span>
  15 |     | <span class='neutral'>     * It is unsafe to assume that an address for which this function returns</span>
  16 |     | <span class='neutral'>     * false is an externally-owned account (EOA) and not a contract.</span>
  17 |     | <span class='neutral'>     *</span>
  18 |     | <span class='neutral'>     * Among others, `isContract` will return false for the following</span>
  19 |     | <span class='neutral'>     * types of addresses:</span>
  20 |     | <span class='neutral'>     *</span>
  21 |     | <span class='neutral'>     *  - an externally-owned account</span>
  22 |     | <span class='neutral'>     *  - a contract in construction</span>
  23 |     | <span class='neutral'>     *  - an address where a contract will be created</span>
  24 |     | <span class='neutral'>     *  - an address where a contract lived, but was destroyed</span>
  25 |     | <span class='neutral'>     *</span>
  26 |     | <span class='neutral'>     * Furthermore, `isContract` will also return true if the target contract within</span>
  27 |     | <span class='neutral'>     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,</span>
  28 |     | <span class='neutral'>     * which only has an effect at the end of a transaction.</span>
  29 |     | <span class='neutral'>     * ====</span>
  30 |     | <span class='neutral'>     *</span>
  31 |     | <span class='neutral'>     * [IMPORTANT]</span>
  32 |     | <span class='neutral'>     * ====</span>
  33 |     | <span class='neutral'>     * You shouldn&#39;t rely on `isContract` to protect against flash loan attacks!</span>
  34 |     | <span class='neutral'>     *</span>
  35 |     | <span class='neutral'>     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets</span>
  36 |     | <span class='neutral'>     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract</span>
  37 |     | <span class='neutral'>     * constructor.</span>
  38 |     | <span class='neutral'>     * ====</span>
  39 |     | <span class='neutral'>     */</span>
  40 |     | <span class='neutral'>    function isContract(address account) internal view returns (bool) {</span>
  41 |     | <span class='neutral'>        // This method relies on extcodesize/address.code.length, which returns 0</span>
  42 |     | <span class='neutral'>        // for contracts in construction, since the code is only stored at the end</span>
  43 |     | <span class='neutral'>        // of the constructor execution.</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='unexecuted'>        return account.code.length &gt; 0;</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /**</span>
  49 |     | <span class='neutral'>     * @dev Replacement for Solidity&#39;s `transfer`: sends `amount` wei to</span>
  50 |     | <span class='neutral'>     * `recipient`, forwarding all available gas and reverting on errors.</span>
  51 |     | <span class='neutral'>     *</span>
  52 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost</span>
  53 |     | <span class='neutral'>     * of certain opcodes, possibly making contracts go over the 2300 gas limit</span>
  54 |     | <span class='neutral'>     * imposed by `transfer`, making them unable to receive funds via</span>
  55 |     | <span class='neutral'>     * `transfer`. {sendValue} removes this limitation.</span>
  56 |     | <span class='neutral'>     *</span>
  57 |     | <span class='neutral'>     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].</span>
  58 |     | <span class='neutral'>     *</span>
  59 |     | <span class='neutral'>     * IMPORTANT: because control is transferred to `recipient`, care must be</span>
  60 |     | <span class='neutral'>     * taken to not create reentrancy vulnerabilities. Consider using</span>
  61 |     | <span class='neutral'>     * {ReentrancyGuard} or the</span>
  62 |     | <span class='neutral'>     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].</span>
  63 |     | <span class='neutral'>     */</span>
  64 |     | <span class='neutral'>    function sendValue(address payable recipient, uint256 amount) internal {</span>
  65 |     | <span class='neutral'>        require(address(this).balance &gt;= amount, &quot;Address: insufficient balance&quot;);</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>        (bool success, ) = recipient.call{value: amount}(&quot;&quot;);</span>
  68 |     | <span class='neutral'>        require(success, &quot;Address: unable to send value, recipient may have reverted&quot;);</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    /**</span>
  72 |     | <span class='neutral'>     * @dev Performs a Solidity function call using a low level `call`. A</span>
  73 |     | <span class='neutral'>     * plain `call` is an unsafe replacement for a function call: use this</span>
  74 |     | <span class='neutral'>     * function instead.</span>
  75 |     | <span class='neutral'>     *</span>
  76 |     | <span class='neutral'>     * If `target` reverts with a revert reason, it is bubbled up by this</span>
  77 |     | <span class='neutral'>     * function (like regular Solidity function calls).</span>
  78 |     | <span class='neutral'>     *</span>
  79 |     | <span class='neutral'>     * Returns the raw returned data. To convert to the expected return value,</span>
  80 |     | <span class='neutral'>     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].</span>
  81 |     | <span class='neutral'>     *</span>
  82 |     | <span class='neutral'>     * Requirements:</span>
  83 |     | <span class='neutral'>     *</span>
  84 |     | <span class='neutral'>     * - `target` must be a contract.</span>
  85 |     | <span class='neutral'>     * - calling `target` with `data` must not revert.</span>
  86 |     | <span class='neutral'>     *</span>
  87 |     | <span class='neutral'>     * _Available since v3.1._</span>
  88 |     | <span class='neutral'>     */</span>
  89 |     | <span class='neutral'>    function functionCall(address target, bytes memory data) internal returns (bytes memory) {</span>
  90 |     | <span class='neutral'>        return functionCallWithValue(target, data, 0, &quot;Address: low-level call failed&quot;);</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    /**</span>
  94 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with</span>
  95 |     | <span class='neutral'>     * `errorMessage` as a fallback revert reason when `target` reverts.</span>
  96 |     | <span class='neutral'>     *</span>
  97 |     | <span class='neutral'>     * _Available since v3.1._</span>
  98 |     | <span class='neutral'>     */</span>
  99 |     | <span class='neutral'>    function functionCall(</span>
 100 |     | <span class='neutral'>        address target,</span>
 101 |     | <span class='neutral'>        bytes memory data,</span>
 102 |     | <span class='neutral'>        string memory errorMessage</span>
 103 |     | <span class='neutral'>    ) internal returns (bytes memory) {</span>
 104 |     | <span class='neutral'>        return functionCallWithValue(target, data, 0, errorMessage);</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    /**</span>
 108 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
 109 |     | <span class='neutral'>     * but also transferring `value` wei to `target`.</span>
 110 |     | <span class='neutral'>     *</span>
 111 |     | <span class='neutral'>     * Requirements:</span>
 112 |     | <span class='neutral'>     *</span>
 113 |     | <span class='neutral'>     * - the calling contract must have an ETH balance of at least `value`.</span>
 114 |     | <span class='neutral'>     * - the called Solidity function must be `payable`.</span>
 115 |     | <span class='neutral'>     *</span>
 116 |     | <span class='neutral'>     * _Available since v3.1._</span>
 117 |     | <span class='neutral'>     */</span>
 118 |     | <span class='neutral'>    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {</span>
 119 |     | <span class='neutral'>        return functionCallWithValue(target, data, value, &quot;Address: low-level call with value failed&quot;);</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /**</span>
 123 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but</span>
 124 |     | <span class='neutral'>     * with `errorMessage` as a fallback revert reason when `target` reverts.</span>
 125 |     | <span class='neutral'>     *</span>
 126 |     | <span class='neutral'>     * _Available since v3.1._</span>
 127 |     | <span class='neutral'>     */</span>
 128 |     | <span class='neutral'>    function functionCallWithValue(</span>
 129 |     | <span class='neutral'>        address target,</span>
 130 |     | <span class='neutral'>        bytes memory data,</span>
 131 |     | <span class='neutral'>        uint256 value,</span>
 132 |     | <span class='neutral'>        string memory errorMessage</span>
 133 |     | <span class='neutral'>    ) internal returns (bytes memory) {</span>
 134 |     | <span class='neutral'>        require(address(this).balance &gt;= value, &quot;Address: insufficient balance for call&quot;);</span>
 135 |     | <span class='neutral'>        (bool success, bytes memory returndata) = target.call{value: value}(data);</span>
 136 |     | <span class='neutral'>        return verifyCallResultFromTarget(target, success, returndata, errorMessage);</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    /**</span>
 140 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
 141 |     | <span class='neutral'>     * but performing a static call.</span>
 142 |     | <span class='neutral'>     *</span>
 143 |     | <span class='neutral'>     * _Available since v3.3._</span>
 144 |     | <span class='neutral'>     */</span>
 145 |     | <span class='neutral'>    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {</span>
 146 |     | <span class='neutral'>        return functionStaticCall(target, data, &quot;Address: low-level static call failed&quot;);</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /**</span>
 150 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],</span>
 151 |     | <span class='neutral'>     * but performing a static call.</span>
 152 |     | <span class='neutral'>     *</span>
 153 |     | <span class='neutral'>     * _Available since v3.3._</span>
 154 |     | <span class='neutral'>     */</span>
 155 |     | <span class='neutral'>    function functionStaticCall(</span>
 156 |     | <span class='neutral'>        address target,</span>
 157 |     | <span class='neutral'>        bytes memory data,</span>
 158 |     | <span class='neutral'>        string memory errorMessage</span>
 159 |     | <span class='neutral'>    ) internal view returns (bytes memory) {</span>
 160 |     | <span class='neutral'>        (bool success, bytes memory returndata) = target.staticcall(data);</span>
 161 |     | <span class='neutral'>        return verifyCallResultFromTarget(target, success, returndata, errorMessage);</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    /**</span>
 165 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
 166 |     | <span class='neutral'>     * but performing a delegate call.</span>
 167 |     | <span class='neutral'>     *</span>
 168 |     | <span class='neutral'>     * _Available since v3.4._</span>
 169 |     | <span class='neutral'>     */</span>
 170 |     | <span class='neutral'>    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {</span>
 171 |     | <span class='neutral'>        return functionDelegateCall(target, data, &quot;Address: low-level delegate call failed&quot;);</span>
 172 |     | <span class='neutral'>    }</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>    /**</span>
 175 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],</span>
 176 |     | <span class='neutral'>     * but performing a delegate call.</span>
 177 |     | <span class='neutral'>     *</span>
 178 |     | <span class='neutral'>     * _Available since v3.4._</span>
 179 |     | <span class='neutral'>     */</span>
 180 |     | <span class='neutral'>    function functionDelegateCall(</span>
 181 |     | <span class='neutral'>        address target,</span>
 182 |     | <span class='neutral'>        bytes memory data,</span>
 183 |     | <span class='neutral'>        string memory errorMessage</span>
 184 |     | <span class='neutral'>    ) internal returns (bytes memory) {</span>
 185 |     | <span class='neutral'>        (bool success, bytes memory returndata) = target.delegatecall(data);</span>
 186 |     | <span class='neutral'>        return verifyCallResultFromTarget(target, success, returndata, errorMessage);</span>
 187 |     | <span class='neutral'>    }</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>    /**</span>
 190 |     | <span class='neutral'>     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling</span>
 191 |     | <span class='neutral'>     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.</span>
 192 |     | <span class='neutral'>     *</span>
 193 |     | <span class='neutral'>     * _Available since v4.8._</span>
 194 |     | <span class='neutral'>     */</span>
 195 |     | <span class='neutral'>    function verifyCallResultFromTarget(</span>
 196 |     | <span class='neutral'>        address target,</span>
 197 |     | <span class='neutral'>        bool success,</span>
 198 |     | <span class='neutral'>        bytes memory returndata,</span>
 199 |     | <span class='neutral'>        string memory errorMessage</span>
 200 |     | <span class='neutral'>    ) internal view returns (bytes memory) {</span>
 201 |     | <span class='neutral'>        if (success) {</span>
 202 |     | <span class='neutral'>            if (returndata.length == 0) {</span>
 203 |     | <span class='neutral'>                // only check isContract if the call was successful and the return data is empty</span>
 204 |     | <span class='neutral'>                // otherwise we already know that it was a contract</span>
 205 |     | <span class='neutral'>                require(isContract(target), &quot;Address: call to non-contract&quot;);</span>
 206 |     | <span class='neutral'>            }</span>
 207 |     | <span class='neutral'>            return returndata;</span>
 208 |     | <span class='neutral'>        } else {</span>
 209 |     | <span class='neutral'>            _revert(returndata, errorMessage);</span>
 210 |     | <span class='neutral'>        }</span>
 211 |     | <span class='neutral'>    }</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='neutral'>    /**</span>
 214 |     | <span class='neutral'>     * @dev Tool to verify that a low level call was successful, and revert if it wasn&#39;t, either by bubbling the</span>
 215 |     | <span class='neutral'>     * revert reason or using the provided one.</span>
 216 |     | <span class='neutral'>     *</span>
 217 |     | <span class='neutral'>     * _Available since v4.3._</span>
 218 |     | <span class='neutral'>     */</span>
 219 |     | <span class='neutral'>    function verifyCallResult(</span>
 220 |     | <span class='neutral'>        bool success,</span>
 221 |     | <span class='neutral'>        bytes memory returndata,</span>
 222 |     | <span class='neutral'>        string memory errorMessage</span>
 223 |     | <span class='neutral'>    ) internal pure returns (bytes memory) {</span>
 224 |     | <span class='neutral'>        if (success) {</span>
 225 |     | <span class='neutral'>            return returndata;</span>
 226 |     | <span class='neutral'>        } else {</span>
 227 |     | <span class='neutral'>            _revert(returndata, errorMessage);</span>
 228 |     | <span class='neutral'>        }</span>
 229 |     | <span class='neutral'>    }</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='neutral'>    function _revert(bytes memory returndata, string memory errorMessage) private pure {</span>
 232 |     | <span class='neutral'>        // Look for revert reason and bubble it up if present</span>
 233 |     | <span class='neutral'>        if (returndata.length &gt; 0) {</span>
 234 |     | <span class='neutral'>            // The easiest way to bubble the revert reason is using memory via assembly</span>
 235 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 236 |     | <span class='neutral'>            assembly {</span>
 237 |     | <span class='neutral'>                let returndata_size := mload(returndata)</span>
 238 |     | <span class='neutral'>                revert(add(32, returndata), returndata_size)</span>
 239 |     | <span class='neutral'>            }</span>
 240 |     | <span class='neutral'>        } else {</span>
 241 |     | <span class='neutral'>            revert(errorMessage);</span>
 242 |     | <span class='neutral'>        }</span>
 243 |     | <span class='neutral'>    }</span>
 244 |     | <span class='neutral'>}</span>
 245 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/utils/Context.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Provides information about the current execution context, including the</span>
  8 |     | <span class='neutral'> * sender of the transaction and its data. While these are generally available</span>
  9 |     | <span class='neutral'> * via msg.sender and msg.data, they should not be accessed in such a direct</span>
 10 |     | <span class='neutral'> * manner, since when dealing with meta-transactions the account sending and</span>
 11 |     | <span class='neutral'> * paying for execution may not be the actual sender (as far as an application</span>
 12 |     | <span class='neutral'> * is concerned).</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * This contract is only required for intermediate, library-like contracts.</span>
 15 |     | <span class='neutral'> */</span>
 16 |     | <span class='neutral'>abstract contract Context {</span>
 17 | *   | <span class='executed'>    function _msgSender() internal view virtual returns (address) {</span>
 18 | *   | <span class='executed'>        return msg.sender;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function _msgData() internal view virtual returns (bytes calldata) {</span>
 22 |     | <span class='neutral'>        return msg.data;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/utils/Strings.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;./math/Math.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;./math/SignedMath.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/**</span>
 10 |     | <span class='neutral'> * @dev String operations.</span>
 11 |     | <span class='neutral'> */</span>
 12 |     | <span class='unexecuted'>library Strings {</span>
 13 |     | <span class='neutral'>    bytes16 private constant _SYMBOLS = &quot;0123456789abcdef&quot;;</span>
 14 |     | <span class='neutral'>    uint8 private constant _ADDRESS_LENGTH = 20;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    /**</span>
 17 |     | <span class='neutral'>     * @dev Converts a `uint256` to its ASCII `string` decimal representation.</span>
 18 |     | <span class='neutral'>     */</span>
 19 |     | <span class='unexecuted'>    function toString(uint256 value) internal pure returns (string memory) {</span>
 20 |     | <span class='neutral'>        unchecked {</span>
 21 |     | <span class='unexecuted'>            uint256 length = Math.log10(value) + 1;</span>
 22 |     | <span class='unexecuted'>            string memory buffer = new string(length);</span>
 23 |     | <span class='neutral'>            uint256 ptr;</span>
 24 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 25 |     | <span class='neutral'>            assembly {</span>
 26 |     | <span class='unexecuted'>                ptr := add(buffer, add(32, length))</span>
 27 |     | <span class='neutral'>            }</span>
 28 |     | <span class='unexecuted'>            while (true) {</span>
 29 |     | <span class='unexecuted'>                ptr--;</span>
 30 |     | <span class='neutral'>                /// @solidity memory-safe-assembly</span>
 31 |     | <span class='neutral'>                assembly {</span>
 32 |     | <span class='unexecuted'>                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))</span>
 33 |     | <span class='neutral'>                }</span>
 34 |     | <span class='unexecuted'>                value /= 10;</span>
 35 |     | <span class='unexecuted'>                if (value == 0) break;</span>
 36 |     | <span class='neutral'>            }</span>
 37 |     | <span class='unexecuted'>            return buffer;</span>
 38 |     | <span class='neutral'>        }</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    /**</span>
 42 |     | <span class='neutral'>     * @dev Converts a `int256` to its ASCII `string` decimal representation.</span>
 43 |     | <span class='neutral'>     */</span>
 44 |     | <span class='neutral'>    function toString(int256 value) internal pure returns (string memory) {</span>
 45 |     | <span class='neutral'>        return string(abi.encodePacked(value &lt; 0 ? &quot;-&quot; : &quot;&quot;, toString(SignedMath.abs(value))));</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    /**</span>
 49 |     | <span class='neutral'>     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.</span>
 50 |     | <span class='neutral'>     */</span>
 51 |     | <span class='neutral'>    function toHexString(uint256 value) internal pure returns (string memory) {</span>
 52 |     | <span class='neutral'>        unchecked {</span>
 53 |     | <span class='neutral'>            return toHexString(value, Math.log256(value) + 1);</span>
 54 |     | <span class='neutral'>        }</span>
 55 |     | <span class='neutral'>    }</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='neutral'>    /**</span>
 58 |     | <span class='neutral'>     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.</span>
 59 |     | <span class='neutral'>     */</span>
 60 |     | <span class='neutral'>    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {</span>
 61 |     | <span class='neutral'>        bytes memory buffer = new bytes(2 * length + 2);</span>
 62 |     | <span class='neutral'>        buffer[0] = &quot;0&quot;;</span>
 63 |     | <span class='neutral'>        buffer[1] = &quot;x&quot;;</span>
 64 |     | <span class='neutral'>        for (uint256 i = 2 * length + 1; i &gt; 1; --i) {</span>
 65 |     | <span class='neutral'>            buffer[i] = _SYMBOLS[value &amp; 0xf];</span>
 66 |     | <span class='neutral'>            value &gt;&gt;= 4;</span>
 67 |     | <span class='neutral'>        }</span>
 68 |     | <span class='neutral'>        require(value == 0, &quot;Strings: hex length insufficient&quot;);</span>
 69 |     | <span class='neutral'>        return string(buffer);</span>
 70 |     | <span class='neutral'>    }</span>
 71 |     | <span class='neutral'></span>
 72 |     | <span class='neutral'>    /**</span>
 73 |     | <span class='neutral'>     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.</span>
 74 |     | <span class='neutral'>     */</span>
 75 |     | <span class='neutral'>    function toHexString(address addr) internal pure returns (string memory) {</span>
 76 |     | <span class='neutral'>        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);</span>
 77 |     | <span class='neutral'>    }</span>
 78 |     | <span class='neutral'></span>
 79 |     | <span class='neutral'>    /**</span>
 80 |     | <span class='neutral'>     * @dev Returns true if the two strings are equal.</span>
 81 |     | <span class='neutral'>     */</span>
 82 |     | <span class='neutral'>    function equal(string memory a, string memory b) internal pure returns (bool) {</span>
 83 |     | <span class='neutral'>        return keccak256(bytes(a)) == keccak256(bytes(b));</span>
 84 |     | <span class='neutral'>    }</span>
 85 |     | <span class='neutral'>}</span>
 86 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;./IERC165.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Implementation of the {IERC165} interface.</span>
 10 |     | <span class='neutral'> *</span>
 11 |     | <span class='neutral'> * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check</span>
 12 |     | <span class='neutral'> * for the additional interface id that will be supported. For example:</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * ```solidity</span>
 15 |     | <span class='neutral'> * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {</span>
 16 |     | <span class='neutral'> *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);</span>
 17 |     | <span class='neutral'> * }</span>
 18 |     | <span class='neutral'> * ```</span>
 19 |     | <span class='neutral'> *</span>
 20 |     | <span class='neutral'> * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.</span>
 21 |     | <span class='neutral'> */</span>
 22 |     | <span class='neutral'>abstract contract ERC165 is IERC165 {</span>
 23 |     | <span class='neutral'>    /**</span>
 24 |     | <span class='neutral'>     * @dev See {IERC165-supportsInterface}.</span>
 25 |     | <span class='neutral'>     */</span>
 26 | *   | <span class='executed'>    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {</span>
 27 | *   | <span class='executed'>        return interfaceId == type(IERC165).interfaceId;</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'>}</span>
 30 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC165 standard, as defined in the</span>
  8 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-165[EIP].</span>
  9 |     | <span class='neutral'> *</span>
 10 |     | <span class='neutral'> * Implementers can declare support of contract interfaces, which can then be</span>
 11 |     | <span class='neutral'> * queried by others ({ERC165Checker}).</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> * For an implementation, see {ERC165}.</span>
 14 |     | <span class='neutral'> */</span>
 15 |     | <span class='neutral'>interface IERC165 {</span>
 16 |     | <span class='neutral'>    /**</span>
 17 |     | <span class='neutral'>     * @dev Returns true if this contract implements the interface defined by</span>
 18 |     | <span class='neutral'>     * `interfaceId`. See the corresponding</span>
 19 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]</span>
 20 |     | <span class='neutral'>     * to learn more about how these ids are created.</span>
 21 |     | <span class='neutral'>     *</span>
 22 |     | <span class='neutral'>     * This function call must use less than 30 000 gas.</span>
 23 |     | <span class='neutral'>     */</span>
 24 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceId) external view returns (bool);</span>
 25 |     | <span class='neutral'>}</span>
 26 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/utils/math/Math.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @dev Standard math utilities missing in the Solidity language.</span>
   8 |     | <span class='neutral'> */</span>
   9 |     | <span class='unexecuted'>library Math {</span>
  10 |     | <span class='neutral'>    enum Rounding {</span>
  11 |     | <span class='neutral'>        Down, // Toward negative infinity</span>
  12 |     | <span class='neutral'>        Up, // Toward infinity</span>
  13 |     | <span class='neutral'>        Zero // Toward zero</span>
  14 |     | <span class='neutral'>    }</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    /**</span>
  17 |     | <span class='neutral'>     * @dev Returns the largest of two numbers.</span>
  18 |     | <span class='neutral'>     */</span>
  19 |     | <span class='neutral'>    function max(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  20 |     | <span class='neutral'>        return a &gt; b ? a : b;</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    /**</span>
  24 |     | <span class='neutral'>     * @dev Returns the smallest of two numbers.</span>
  25 |     | <span class='neutral'>     */</span>
  26 |     | <span class='neutral'>    function min(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  27 |     | <span class='neutral'>        return a &lt; b ? a : b;</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /**</span>
  31 |     | <span class='neutral'>     * @dev Returns the average of two numbers. The result is rounded towards</span>
  32 |     | <span class='neutral'>     * zero.</span>
  33 |     | <span class='neutral'>     */</span>
  34 |     | <span class='neutral'>    function average(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  35 |     | <span class='neutral'>        // (a + b) / 2 can overflow.</span>
  36 |     | <span class='neutral'>        return (a &amp; b) + (a ^ b) / 2;</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    /**</span>
  40 |     | <span class='neutral'>     * @dev Returns the ceiling of the division of two numbers.</span>
  41 |     | <span class='neutral'>     *</span>
  42 |     | <span class='neutral'>     * This differs from standard division with `/` in that it rounds up instead</span>
  43 |     | <span class='neutral'>     * of rounding down.</span>
  44 |     | <span class='neutral'>     */</span>
  45 |     | <span class='neutral'>    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  46 |     | <span class='neutral'>        // (a + b - 1) / b can overflow on addition, so we distribute.</span>
  47 |     | <span class='neutral'>        return a == 0 ? 0 : (a - 1) / b + 1;</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /**</span>
  51 |     | <span class='neutral'>     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0</span>
  52 |     | <span class='neutral'>     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)</span>
  53 |     | <span class='neutral'>     * with further edits by Uniswap Labs also under MIT license.</span>
  54 |     | <span class='neutral'>     */</span>
  55 |     | <span class='neutral'>    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {</span>
  56 |     | <span class='neutral'>        unchecked {</span>
  57 |     | <span class='neutral'>            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use</span>
  58 |     | <span class='neutral'>            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256</span>
  59 |     | <span class='neutral'>            // variables such that product = prod1 * 2^256 + prod0.</span>
  60 |     | <span class='neutral'>            uint256 prod0; // Least significant 256 bits of the product</span>
  61 |     | <span class='neutral'>            uint256 prod1; // Most significant 256 bits of the product</span>
  62 |     | <span class='neutral'>            assembly {</span>
  63 |     | <span class='neutral'>                let mm := mulmod(x, y, not(0))</span>
  64 |     | <span class='neutral'>                prod0 := mul(x, y)</span>
  65 |     | <span class='neutral'>                prod1 := sub(sub(mm, prod0), lt(mm, prod0))</span>
  66 |     | <span class='neutral'>            }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>            // Handle non-overflow cases, 256 by 256 division.</span>
  69 |     | <span class='neutral'>            if (prod1 == 0) {</span>
  70 |     | <span class='neutral'>                return prod0 / denominator;</span>
  71 |     | <span class='neutral'>            }</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>            // Make sure the result is less than 2^256. Also prevents denominator == 0.</span>
  74 |     | <span class='neutral'>            require(denominator &gt; prod1, &quot;Math: mulDiv overflow&quot;);</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>            ///////////////////////////////////////////////</span>
  77 |     | <span class='neutral'>            // 512 by 256 division.</span>
  78 |     | <span class='neutral'>            ///////////////////////////////////////////////</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>            // Make division exact by subtracting the remainder from [prod1 prod0].</span>
  81 |     | <span class='neutral'>            uint256 remainder;</span>
  82 |     | <span class='neutral'>            assembly {</span>
  83 |     | <span class='neutral'>                // Compute remainder using mulmod.</span>
  84 |     | <span class='neutral'>                remainder := mulmod(x, y, denominator)</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>                // Subtract 256 bit number from 512 bit number.</span>
  87 |     | <span class='neutral'>                prod1 := sub(prod1, gt(remainder, prod0))</span>
  88 |     | <span class='neutral'>                prod0 := sub(prod0, remainder)</span>
  89 |     | <span class='neutral'>            }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always &gt;= 1.</span>
  92 |     | <span class='neutral'>            // See https://cs.stackexchange.com/q/138556/92363.</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>            // Does not overflow because the denominator cannot be zero at this stage in the function.</span>
  95 |     | <span class='neutral'>            uint256 twos = denominator &amp; (~denominator + 1);</span>
  96 |     | <span class='neutral'>            assembly {</span>
  97 |     | <span class='neutral'>                // Divide denominator by twos.</span>
  98 |     | <span class='neutral'>                denominator := div(denominator, twos)</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>                // Divide [prod1 prod0] by twos.</span>
 101 |     | <span class='neutral'>                prod0 := div(prod0, twos)</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.</span>
 104 |     | <span class='neutral'>                twos := add(div(sub(0, twos), twos), 1)</span>
 105 |     | <span class='neutral'>            }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>            // Shift in bits from prod1 into prod0.</span>
 108 |     | <span class='neutral'>            prod0 |= prod1 * twos;</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such</span>
 111 |     | <span class='neutral'>            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for</span>
 112 |     | <span class='neutral'>            // four bits. That is, denominator * inv = 1 mod 2^4.</span>
 113 |     | <span class='neutral'>            uint256 inverse = (3 * denominator) ^ 2;</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel&#39;s lifting lemma, this also works</span>
 116 |     | <span class='neutral'>            // in modular arithmetic, doubling the correct bits in each step.</span>
 117 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^8</span>
 118 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^16</span>
 119 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^32</span>
 120 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^64</span>
 121 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^128</span>
 122 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^256</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.</span>
 125 |     | <span class='neutral'>            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is</span>
 126 |     | <span class='neutral'>            // less than 2^256, this is the final result. We don&#39;t need to compute the high bits of the result and prod1</span>
 127 |     | <span class='neutral'>            // is no longer required.</span>
 128 |     | <span class='neutral'>            result = prod0 * inverse;</span>
 129 |     | <span class='neutral'>            return result;</span>
 130 |     | <span class='neutral'>        }</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>    /**</span>
 134 |     | <span class='neutral'>     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.</span>
 135 |     | <span class='neutral'>     */</span>
 136 |     | <span class='neutral'>    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {</span>
 137 |     | <span class='neutral'>        uint256 result = mulDiv(x, y, denominator);</span>
 138 |     | <span class='neutral'>        if (rounding == Rounding.Up &amp;&amp; mulmod(x, y, denominator) &gt; 0) {</span>
 139 |     | <span class='neutral'>            result += 1;</span>
 140 |     | <span class='neutral'>        }</span>
 141 |     | <span class='neutral'>        return result;</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>    /**</span>
 145 |     | <span class='neutral'>     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.</span>
 146 |     | <span class='neutral'>     *</span>
 147 |     | <span class='neutral'>     * Inspired by Henry S. Warren, Jr.&#39;s &quot;Hacker&#39;s Delight&quot; (Chapter 11).</span>
 148 |     | <span class='neutral'>     */</span>
 149 |     | <span class='neutral'>    function sqrt(uint256 a) internal pure returns (uint256) {</span>
 150 |     | <span class='neutral'>        if (a == 0) {</span>
 151 |     | <span class='neutral'>            return 0;</span>
 152 |     | <span class='neutral'>        }</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.</span>
 155 |     | <span class='neutral'>        //</span>
 156 |     | <span class='neutral'>        // We know that the &quot;msb&quot; (most significant bit) of our target number `a` is a power of 2 such that we have</span>
 157 |     | <span class='neutral'>        // `msb(a) &lt;= a &lt; 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.</span>
 158 |     | <span class='neutral'>        //</span>
 159 |     | <span class='neutral'>        // This can be rewritten `2**log2(a) &lt;= a &lt; 2**(log2(a) + 1)`</span>
 160 |     | <span class='neutral'>        // → `sqrt(2**k) &lt;= sqrt(a) &lt; sqrt(2**(k+1))`</span>
 161 |     | <span class='neutral'>        // → `2**(k/2) &lt;= sqrt(a) &lt; 2**((k+1)/2) &lt;= 2**(k/2 + 1)`</span>
 162 |     | <span class='neutral'>        //</span>
 163 |     | <span class='neutral'>        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.</span>
 164 |     | <span class='neutral'>        uint256 result = 1 &lt;&lt; (log2(a) &gt;&gt; 1);</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,</span>
 167 |     | <span class='neutral'>        // since it is the square root of a uint256. Newton&#39;s method converges quadratically (precision doubles at</span>
 168 |     | <span class='neutral'>        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision</span>
 169 |     | <span class='neutral'>        // into the expected uint128 result.</span>
 170 |     | <span class='neutral'>        unchecked {</span>
 171 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 172 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 173 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 174 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 175 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 176 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 177 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 178 |     | <span class='neutral'>            return min(result, a / result);</span>
 179 |     | <span class='neutral'>        }</span>
 180 |     | <span class='neutral'>    }</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>    /**</span>
 183 |     | <span class='neutral'>     * @notice Calculates sqrt(a), following the selected rounding direction.</span>
 184 |     | <span class='neutral'>     */</span>
 185 |     | <span class='neutral'>    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {</span>
 186 |     | <span class='neutral'>        unchecked {</span>
 187 |     | <span class='neutral'>            uint256 result = sqrt(a);</span>
 188 |     | <span class='neutral'>            return result + (rounding == Rounding.Up &amp;&amp; result * result &lt; a ? 1 : 0);</span>
 189 |     | <span class='neutral'>        }</span>
 190 |     | <span class='neutral'>    }</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='neutral'>    /**</span>
 193 |     | <span class='neutral'>     * @dev Return the log in base 2, rounded down, of a positive value.</span>
 194 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 195 |     | <span class='neutral'>     */</span>
 196 |     | <span class='neutral'>    function log2(uint256 value) internal pure returns (uint256) {</span>
 197 |     | <span class='neutral'>        uint256 result = 0;</span>
 198 |     | <span class='neutral'>        unchecked {</span>
 199 |     | <span class='neutral'>            if (value &gt;&gt; 128 &gt; 0) {</span>
 200 |     | <span class='neutral'>                value &gt;&gt;= 128;</span>
 201 |     | <span class='neutral'>                result += 128;</span>
 202 |     | <span class='neutral'>            }</span>
 203 |     | <span class='neutral'>            if (value &gt;&gt; 64 &gt; 0) {</span>
 204 |     | <span class='neutral'>                value &gt;&gt;= 64;</span>
 205 |     | <span class='neutral'>                result += 64;</span>
 206 |     | <span class='neutral'>            }</span>
 207 |     | <span class='neutral'>            if (value &gt;&gt; 32 &gt; 0) {</span>
 208 |     | <span class='neutral'>                value &gt;&gt;= 32;</span>
 209 |     | <span class='neutral'>                result += 32;</span>
 210 |     | <span class='neutral'>            }</span>
 211 |     | <span class='neutral'>            if (value &gt;&gt; 16 &gt; 0) {</span>
 212 |     | <span class='neutral'>                value &gt;&gt;= 16;</span>
 213 |     | <span class='neutral'>                result += 16;</span>
 214 |     | <span class='neutral'>            }</span>
 215 |     | <span class='neutral'>            if (value &gt;&gt; 8 &gt; 0) {</span>
 216 |     | <span class='neutral'>                value &gt;&gt;= 8;</span>
 217 |     | <span class='neutral'>                result += 8;</span>
 218 |     | <span class='neutral'>            }</span>
 219 |     | <span class='neutral'>            if (value &gt;&gt; 4 &gt; 0) {</span>
 220 |     | <span class='neutral'>                value &gt;&gt;= 4;</span>
 221 |     | <span class='neutral'>                result += 4;</span>
 222 |     | <span class='neutral'>            }</span>
 223 |     | <span class='neutral'>            if (value &gt;&gt; 2 &gt; 0) {</span>
 224 |     | <span class='neutral'>                value &gt;&gt;= 2;</span>
 225 |     | <span class='neutral'>                result += 2;</span>
 226 |     | <span class='neutral'>            }</span>
 227 |     | <span class='neutral'>            if (value &gt;&gt; 1 &gt; 0) {</span>
 228 |     | <span class='neutral'>                result += 1;</span>
 229 |     | <span class='neutral'>            }</span>
 230 |     | <span class='neutral'>        }</span>
 231 |     | <span class='neutral'>        return result;</span>
 232 |     | <span class='neutral'>    }</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='neutral'>    /**</span>
 235 |     | <span class='neutral'>     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.</span>
 236 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 237 |     | <span class='neutral'>     */</span>
 238 |     | <span class='neutral'>    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {</span>
 239 |     | <span class='neutral'>        unchecked {</span>
 240 |     | <span class='neutral'>            uint256 result = log2(value);</span>
 241 |     | <span class='neutral'>            return result + (rounding == Rounding.Up &amp;&amp; 1 &lt;&lt; result &lt; value ? 1 : 0);</span>
 242 |     | <span class='neutral'>        }</span>
 243 |     | <span class='neutral'>    }</span>
 244 |     | <span class='neutral'></span>
 245 |     | <span class='neutral'>    /**</span>
 246 |     | <span class='neutral'>     * @dev Return the log in base 10, rounded down, of a positive value.</span>
 247 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 248 |     | <span class='neutral'>     */</span>
 249 |     | <span class='unexecuted'>    function log10(uint256 value) internal pure returns (uint256) {</span>
 250 |     | <span class='neutral'>        uint256 result = 0;</span>
 251 |     | <span class='neutral'>        unchecked {</span>
 252 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 64) {</span>
 253 |     | <span class='unexecuted'>                value /= 10 ** 64;</span>
 254 |     | <span class='unexecuted'>                result += 64;</span>
 255 |     | <span class='neutral'>            }</span>
 256 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 32) {</span>
 257 |     | <span class='unexecuted'>                value /= 10 ** 32;</span>
 258 |     | <span class='unexecuted'>                result += 32;</span>
 259 |     | <span class='neutral'>            }</span>
 260 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 16) {</span>
 261 |     | <span class='unexecuted'>                value /= 10 ** 16;</span>
 262 |     | <span class='unexecuted'>                result += 16;</span>
 263 |     | <span class='neutral'>            }</span>
 264 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 8) {</span>
 265 |     | <span class='unexecuted'>                value /= 10 ** 8;</span>
 266 |     | <span class='unexecuted'>                result += 8;</span>
 267 |     | <span class='neutral'>            }</span>
 268 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 4) {</span>
 269 |     | <span class='unexecuted'>                value /= 10 ** 4;</span>
 270 |     | <span class='unexecuted'>                result += 4;</span>
 271 |     | <span class='neutral'>            }</span>
 272 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 2) {</span>
 273 |     | <span class='unexecuted'>                value /= 10 ** 2;</span>
 274 |     | <span class='unexecuted'>                result += 2;</span>
 275 |     | <span class='neutral'>            }</span>
 276 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 1) {</span>
 277 |     | <span class='unexecuted'>                result += 1;</span>
 278 |     | <span class='neutral'>            }</span>
 279 |     | <span class='neutral'>        }</span>
 280 |     | <span class='unexecuted'>        return result;</span>
 281 |     | <span class='neutral'>    }</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='neutral'>    /**</span>
 284 |     | <span class='neutral'>     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.</span>
 285 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 286 |     | <span class='neutral'>     */</span>
 287 |     | <span class='neutral'>    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {</span>
 288 |     | <span class='neutral'>        unchecked {</span>
 289 |     | <span class='neutral'>            uint256 result = log10(value);</span>
 290 |     | <span class='neutral'>            return result + (rounding == Rounding.Up &amp;&amp; 10 ** result &lt; value ? 1 : 0);</span>
 291 |     | <span class='neutral'>        }</span>
 292 |     | <span class='neutral'>    }</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='neutral'>    /**</span>
 295 |     | <span class='neutral'>     * @dev Return the log in base 256, rounded down, of a positive value.</span>
 296 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 297 |     | <span class='neutral'>     *</span>
 298 |     | <span class='neutral'>     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.</span>
 299 |     | <span class='neutral'>     */</span>
 300 |     | <span class='neutral'>    function log256(uint256 value) internal pure returns (uint256) {</span>
 301 |     | <span class='neutral'>        uint256 result = 0;</span>
 302 |     | <span class='neutral'>        unchecked {</span>
 303 |     | <span class='neutral'>            if (value &gt;&gt; 128 &gt; 0) {</span>
 304 |     | <span class='neutral'>                value &gt;&gt;= 128;</span>
 305 |     | <span class='neutral'>                result += 16;</span>
 306 |     | <span class='neutral'>            }</span>
 307 |     | <span class='neutral'>            if (value &gt;&gt; 64 &gt; 0) {</span>
 308 |     | <span class='neutral'>                value &gt;&gt;= 64;</span>
 309 |     | <span class='neutral'>                result += 8;</span>
 310 |     | <span class='neutral'>            }</span>
 311 |     | <span class='neutral'>            if (value &gt;&gt; 32 &gt; 0) {</span>
 312 |     | <span class='neutral'>                value &gt;&gt;= 32;</span>
 313 |     | <span class='neutral'>                result += 4;</span>
 314 |     | <span class='neutral'>            }</span>
 315 |     | <span class='neutral'>            if (value &gt;&gt; 16 &gt; 0) {</span>
 316 |     | <span class='neutral'>                value &gt;&gt;= 16;</span>
 317 |     | <span class='neutral'>                result += 2;</span>
 318 |     | <span class='neutral'>            }</span>
 319 |     | <span class='neutral'>            if (value &gt;&gt; 8 &gt; 0) {</span>
 320 |     | <span class='neutral'>                result += 1;</span>
 321 |     | <span class='neutral'>            }</span>
 322 |     | <span class='neutral'>        }</span>
 323 |     | <span class='neutral'>        return result;</span>
 324 |     | <span class='neutral'>    }</span>
 325 |     | <span class='neutral'></span>
 326 |     | <span class='neutral'>    /**</span>
 327 |     | <span class='neutral'>     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.</span>
 328 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 329 |     | <span class='neutral'>     */</span>
 330 |     | <span class='neutral'>    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {</span>
 331 |     | <span class='neutral'>        unchecked {</span>
 332 |     | <span class='neutral'>            uint256 result = log256(value);</span>
 333 |     | <span class='neutral'>            return result + (rounding == Rounding.Up &amp;&amp; 1 &lt;&lt; (result &lt;&lt; 3) &lt; value ? 1 : 0);</span>
 334 |     | <span class='neutral'>        }</span>
 335 |     | <span class='neutral'>    }</span>
 336 |     | <span class='neutral'>}</span>
 337 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ivruix/Desktop/hw4/lib/properties/lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Standard signed math utilities missing in the Solidity language.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='unexecuted'>library SignedMath {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @dev Returns the largest of two signed numbers.</span>
 12 |     | <span class='neutral'>     */</span>
 13 |     | <span class='neutral'>    function max(int256 a, int256 b) internal pure returns (int256) {</span>
 14 |     | <span class='neutral'>        return a &gt; b ? a : b;</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    /**</span>
 18 |     | <span class='neutral'>     * @dev Returns the smallest of two signed numbers.</span>
 19 |     | <span class='neutral'>     */</span>
 20 |     | <span class='neutral'>    function min(int256 a, int256 b) internal pure returns (int256) {</span>
 21 |     | <span class='neutral'>        return a &lt; b ? a : b;</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the average of two signed numbers without overflow.</span>
 26 |     | <span class='neutral'>     * The result is rounded towards zero.</span>
 27 |     | <span class='neutral'>     */</span>
 28 |     | <span class='neutral'>    function average(int256 a, int256 b) internal pure returns (int256) {</span>
 29 |     | <span class='neutral'>        // Formula from the book &quot;Hacker&#39;s Delight&quot;</span>
 30 |     | <span class='neutral'>        int256 x = (a &amp; b) + ((a ^ b) &gt;&gt; 1);</span>
 31 |     | <span class='neutral'>        return x + (int256(uint256(x) &gt;&gt; 255) &amp; (a ^ b));</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /**</span>
 35 |     | <span class='neutral'>     * @dev Returns the absolute unsigned value of a signed value.</span>
 36 |     | <span class='neutral'>     */</span>
 37 |     | <span class='neutral'>    function abs(int256 n) internal pure returns (uint256) {</span>
 38 |     | <span class='neutral'>        unchecked {</span>
 39 |     | <span class='neutral'>            // must be unchecked in order to support `n = type(int256).min`</span>
 40 |     | <span class='neutral'>            return uint256(n &gt;= 0 ? n : -n);</span>
 41 |     | <span class='neutral'>        }</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'>}</span>
 44 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ivruix/Desktop/hw4/src/MyTokenModified.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC721/ERC721.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>contract MyTokenModified is ERC721, ERC721Enumerable, ERC721Burnable, Ownable {</span>
 10 | *   | <span class='executed'>    uint256 public counter;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='unexecuted'>    constructor() ERC721(&quot;MyTokenModified&quot;, &quot;MTKM&quot;) {}</span>
 13 |     | <span class='neutral'></span>
 14 | *   | <span class='executed'>    function mint(address to, uint256 amount) public {</span>
 15 | *   | <span class='executed'>        for (uint256 i; i &lt; amount; i++) {</span>
 16 | *o  | <span class='executed'>            _mint(to, counter++);</span>
 17 |     | <span class='neutral'>        }</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 | *   | <span class='executed'>    function _beforeTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize)</span>
 21 |     | <span class='neutral'>        internal</span>
 22 |     | <span class='neutral'>        virtual</span>
 23 |     | <span class='neutral'>        override(ERC721, ERC721Enumerable)</span>
 24 |     | <span class='neutral'>    {</span>
 25 | *   | <span class='executed'>        super._beforeTokenTransfer(from, to, tokenId, batchSize);</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'></span>
 28 | *   | <span class='executed'>    function supportsInterface(bytes4 interfaceId)</span>
 29 |     | <span class='neutral'>        public</span>
 30 |     | <span class='neutral'>        view</span>
 31 |     | <span class='neutral'>        virtual</span>
 32 |     | <span class='neutral'>        override(ERC721, ERC721Enumerable)</span>
 33 | *   | <span class='executed'>        returns (bool)</span>
 34 |     | <span class='neutral'>    {</span>
 35 | *   | <span class='executed'>        return super.supportsInterface(interfaceId);</span>
 36 |     | <span class='neutral'>    }</span>
 37 |     | <span class='neutral'></span>
 38 | *   | <span class='executed'>    function ownerOf(uint256 tokenId)</span>
 39 |     | <span class='neutral'>        public</span>
 40 |     | <span class='neutral'>        view</span>
 41 |     | <span class='neutral'>        virtual</span>
 42 |     | <span class='neutral'>        override(ERC721, IERC721)</span>
 43 | *   | <span class='executed'>    returns (address) {</span>
 44 | *   | <span class='executed'>        address owner = _ownerOf(tokenId);</span>
 45 |     | <span class='neutral'>        return owner;</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'></span>
 48 | *   | <span class='executed'>    function balanceOf(address owner)</span>
 49 |     | <span class='neutral'>        public</span>
 50 |     | <span class='neutral'>        view</span>
 51 |     | <span class='neutral'>        virtual</span>
 52 |     | <span class='neutral'>        override(ERC721, IERC721)</span>
 53 | *   | <span class='executed'>    returns (uint256) {</span>
 54 | *   | <span class='executed'>        return _balances[owner];</span>
 55 |     | <span class='neutral'>    }</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='unexecuted'>    function _transfer(address from, address to, uint256 tokenId)</span>
 58 |     | <span class='neutral'>        internal</span>
 59 |     | <span class='neutral'>        virtual</span>
 60 |     | <span class='neutral'>        override</span>
 61 |     | <span class='neutral'>    {</span>
 62 |     | <span class='unexecuted'>        require(ERC721.ownerOf(tokenId) == from, &quot;ERC721: transfer from incorrect owner&quot;);</span>
 63 |     | <span class='unexecuted'>        require(to != address(0), &quot;ERC721: transfer to the zero address&quot;);</span>
 64 |     | <span class='neutral'></span>
 65 |     | <span class='unexecuted'>        _beforeTokenTransfer(from, to, tokenId, 1);</span>
 66 |     | <span class='neutral'></span>
 67 |     | <span class='unexecuted'>        require(ERC721.ownerOf(tokenId) == from, &quot;ERC721: transfer from incorrect owner&quot;);</span>
 68 |     | <span class='neutral'></span>
 69 |     | <span class='neutral'>        unchecked {</span>
 70 |     | <span class='unexecuted'>            _balances[from] -= 1;</span>
 71 |     | <span class='unexecuted'>            _balances[to] += 1;</span>
 72 |     | <span class='neutral'>        }</span>
 73 |     | <span class='unexecuted'>        _owners[tokenId] = to;</span>
 74 |     | <span class='neutral'></span>
 75 |     | <span class='unexecuted'>        emit Transfer(from, to, tokenId);</span>
 76 |     | <span class='neutral'></span>
 77 |     | <span class='neutral'>        _afterTokenTransfer(from, to, tokenId, 1);</span>
 78 |     | <span class='neutral'>    }</span>
 79 |     | <span class='neutral'>}</span>
 80 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ivruix/Desktop/hw4/test/CryticTestExternalModified.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../src/MyTokenModified.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;@crytic/properties/ERC721/util/IERC721Internal.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;@crytic/properties/ERC721/external/properties/ERC721ExternalBasicProperties.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;@crytic/properties/ERC721/external/properties/ERC721ExternalBurnableProperties.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;@crytic/properties/ERC721/external/properties/ERC721ExternalMintableProperties.sol&quot;;</span>
  9 |     | <span class='neutral'>import &quot;@crytic/properties/ERC721/external/util/MockReceiver.sol&quot;;</span>
 10 |     | <span class='neutral'></span>
 11 | *r  | <span class='executed'>contract CryticERC721ExternalHarness is CryticERC721ExternalBasicProperties, CryticERC721ExternalBurnableProperties {</span>
 12 | *   | <span class='executed'>    constructor() {</span>
 13 | *   | <span class='executed'>        token = IERC721Internal(address(new ERC721Mock()));</span>
 14 | *   | <span class='executed'>        mockSafeReceiver = new MockReceiver(true);</span>
 15 | *   | <span class='executed'>        mockUnsafeReceiver = new MockReceiver(false);</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'>}</span>
 18 |     | <span class='neutral'></span>
 19 | *r  | <span class='executed'>contract ERC721Mock is MyTokenModified {</span>
 20 |     | <span class='neutral'>    address constant USER1 = address(0x10000);</span>
 21 |     | <span class='neutral'>    address constant USER2 = address(0x20000);</span>
 22 |     | <span class='neutral'>    address constant USER3 = address(0x30000);</span>
 23 |     | <span class='neutral'></span>
 24 | *   | <span class='executed'>    bool public isMintableOrBurnable;</span>
 25 |     | <span class='neutral'></span>
 26 | *   | <span class='executed'>    function _customMint(address to, uint256 amount) external {</span>
 27 | *   | <span class='executed'>        mint(to, amount);</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'></span>
 30 | *   | <span class='executed'>    constructor() {</span>
 31 | *   | <span class='executed'>        isMintableOrBurnable = true;</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'>}</span>
 34 |     | <span class='neutral'></span>

</code>
<br />

